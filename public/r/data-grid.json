{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-grid",
  "type": "registry:component",
  "title": "Data Grid",
  "description": "A high-performance editable data grid component with virtualization, keyboard navigation, and cell editing",
  "dependencies": [
    "@tanstack/react-table",
    "@tanstack/react-virtual",
    "lucide-react",
    "sonner"
  ],
  "registryDependencies": [
    "badge",
    "button",
    "calendar",
    "checkbox",
    "command",
    "dialog",
    "dropdown-menu",
    "input",
    "kbd",
    "popover",
    "select",
    "separator",
    "textarea",
    "tooltip"
  ],
  "files": [
    {
      "path": "src/components/data-grid/data-grid.tsx",
      "content": "\"use client\";\n\nimport { flexRender } from \"@tanstack/react-table\";\nimport { Plus } from \"lucide-react\";\nimport * as React from \"react\";\nimport { DataGridColumnHeader } from \"@/components/data-grid/data-grid-column-header\";\nimport { DataGridContextMenu } from \"@/components/data-grid/data-grid-context-menu\";\nimport { DataGridKeyboardShortcuts } from \"@/components/data-grid/data-grid-keyboard-shortcuts\";\nimport { DataGridRow } from \"@/components/data-grid/data-grid-row\";\nimport { DataGridSearch } from \"@/components/data-grid/data-grid-search\";\nimport type { useDataGrid } from \"@/hooks/use-data-grid\";\nimport { getCommonPinningStyles } from \"@/lib/data-table\";\nimport { cn } from \"@/lib/utils\";\nimport type { CellPosition } from \"@/types/data-grid\";\n\ninterface DataGridProps<TData>\n  extends ReturnType<typeof useDataGrid<TData>>,\n    React.ComponentProps<\"div\"> {\n  height?: number;\n  onRowAdd?: (event?: React.MouseEvent<HTMLDivElement>) =>\n    | Partial<CellPosition>\n    | Promise<Partial<CellPosition>>\n    | null\n    // biome-ignore lint/suspicious/noConfusingVoidType: void is needed here to allow functions without explicit return\n    | void;\n}\n\nexport function DataGrid<TData>({\n  dataGridRef,\n  headerRef,\n  rowMapRef,\n  footerRef,\n  table,\n  rowVirtualizer,\n  height = 600,\n  searchState,\n  columnSizeVars,\n  scrollToRow,\n  onRowAdd: onRowAddProp,\n  className,\n  ...props\n}: DataGridProps<TData>) {\n  const rows = table.getRowModel().rows;\n  const columns = table.getAllColumns();\n\n  const meta = table.options.meta;\n  const rowHeight = meta?.rowHeight ?? \"short\";\n  const focusedCell = meta?.focusedCell ?? null;\n\n  const onGridContextMenu = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      event.preventDefault();\n    },\n    [],\n  );\n\n  const onRowAdd = React.useCallback(\n    async (event?: React.MouseEvent<HTMLDivElement>) => {\n      if (!onRowAddProp) return;\n\n      const result = await onRowAddProp();\n\n      if (event?.defaultPrevented || result === null) return;\n\n      if (result) {\n        const adjustedRowIndex =\n          (result.rowIndex ?? 0) >= rows.length ? rows.length : result.rowIndex;\n\n        scrollToRow({\n          rowIndex: adjustedRowIndex,\n          columnId: result.columnId,\n        });\n        return;\n      }\n\n      scrollToRow({ rowIndex: rows.length });\n    },\n    [onRowAddProp, scrollToRow, rows.length],\n  );\n\n  const onAddRowKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (!onRowAddProp) return;\n\n      if (event.key === \"Enter\" || event.key === \" \") {\n        event.preventDefault();\n        onRowAdd();\n      }\n    },\n    [onRowAddProp, onRowAdd],\n  );\n\n  return (\n    <div\n      data-slot=\"grid-wrapper\"\n      className={cn(\"relative flex w-full flex-col\", className)}\n      {...props}\n    >\n      {searchState && <DataGridSearch {...searchState} />}\n      <DataGridKeyboardShortcuts enableSearch={!!searchState} />\n      <DataGridContextMenu table={table} />\n      <div\n        role=\"grid\"\n        aria-label=\"Data grid\"\n        aria-rowcount={rows.length + (onRowAddProp ? 1 : 0)}\n        aria-colcount={columns.length}\n        data-slot=\"grid\"\n        tabIndex={0}\n        ref={dataGridRef}\n        className=\"relative grid select-none overflow-auto rounded-md border focus:outline-none\"\n        style={{\n          ...columnSizeVars,\n          height: `${height}px`,\n        }}\n        onContextMenu={onGridContextMenu}\n      >\n        <div\n          role=\"rowgroup\"\n          data-slot=\"grid-header\"\n          ref={headerRef}\n          className=\"sticky top-0 z-10 grid border-b bg-background\"\n        >\n          {table.getHeaderGroups().map((headerGroup, rowIndex) => (\n            <div\n              key={headerGroup.id}\n              role=\"row\"\n              aria-rowindex={rowIndex + 1}\n              data-slot=\"grid-header-row\"\n              tabIndex={-1}\n              className=\"flex w-full\"\n            >\n              {headerGroup.headers.map((header, colIndex) => {\n                const sorting = table.getState().sorting;\n                const currentSort = sorting.find(\n                  (sort) => sort.id === header.column.id,\n                );\n                const isSortable = header.column.getCanSort();\n\n                return (\n                  <div\n                    key={header.id}\n                    role=\"columnheader\"\n                    aria-colindex={colIndex + 1}\n                    aria-sort={\n                      currentSort?.desc === false\n                        ? \"ascending\"\n                        : currentSort?.desc === true\n                          ? \"descending\"\n                          : isSortable\n                            ? \"none\"\n                            : undefined\n                    }\n                    data-slot=\"grid-header-cell\"\n                    tabIndex={-1}\n                    className={cn(\"relative\", {\n                      \"border-r\": header.column.id !== \"select\",\n                    })}\n                    style={{\n                      ...getCommonPinningStyles({ column: header.column }),\n                      width: `calc(var(--header-${header.id}-size) * 1px)`,\n                    }}\n                  >\n                    {header.isPlaceholder ? null : typeof header.column\n                        .columnDef.header === \"function\" ? (\n                      <div className=\"size-full px-3 py-1.5\">\n                        {flexRender(\n                          header.column.columnDef.header,\n                          header.getContext(),\n                        )}\n                      </div>\n                    ) : (\n                      <DataGridColumnHeader header={header} table={table} />\n                    )}\n                  </div>\n                );\n              })}\n            </div>\n          ))}\n        </div>\n        <div\n          role=\"rowgroup\"\n          data-slot=\"grid-body\"\n          className=\"relative grid\"\n          style={{\n            height: `${rowVirtualizer.getTotalSize()}px`,\n          }}\n        >\n          {rowVirtualizer.getVirtualIndexes().map((virtualRowIndex) => {\n            const row = rows[virtualRowIndex];\n            if (!row) return null;\n\n            return (\n              <DataGridRow\n                key={row.id}\n                row={row}\n                rowMapRef={rowMapRef}\n                virtualRowIndex={virtualRowIndex}\n                rowVirtualizer={rowVirtualizer}\n                rowHeight={rowHeight}\n                focusedCell={focusedCell}\n              />\n            );\n          })}\n        </div>\n        {onRowAdd && (\n          <div\n            role=\"rowgroup\"\n            data-slot=\"grid-footer\"\n            ref={footerRef}\n            className=\"sticky bottom-0 z-10 grid border-t bg-background\"\n          >\n            <div\n              role=\"row\"\n              aria-rowindex={rows.length + 2}\n              data-slot=\"grid-add-row\"\n              tabIndex={-1}\n              className=\"flex w-full\"\n            >\n              <div\n                role=\"gridcell\"\n                tabIndex={0}\n                className=\"relative flex h-9 grow items-center bg-muted/30 transition-colors hover:bg-muted/50 focus:bg-muted/50 focus:outline-none\"\n                style={{\n                  width: table.getTotalSize(),\n                  minWidth: table.getTotalSize(),\n                }}\n                onClick={onRowAdd}\n                onKeyDown={onAddRowKeyDown}\n              >\n                <div className=\"sticky left-0 flex items-center gap-2 px-3 text-muted-foreground\">\n                  <Plus className=\"size-3.5\" />\n                  <span className=\"text-sm\">Add row</span>\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-cell.tsx",
      "content": "\"use client\";\n\nimport type { Cell, Table } from \"@tanstack/react-table\";\nimport * as React from \"react\";\n\nimport {\n  CheckboxCell,\n  DateCell,\n  LongTextCell,\n  MultiSelectCell,\n  NumberCell,\n  SelectCell,\n  ShortTextCell,\n} from \"@/components/data-grid/data-grid-cell-variants\";\n\ninterface DataGridCellProps<TData> {\n  cell: Cell<TData, unknown>;\n  table: Table<TData>;\n}\n\nexport function DataGridCell<TData>({ cell, table }: DataGridCellProps<TData>) {\n  const meta = table.options.meta;\n  const originalRowIndex = cell.row.index;\n\n  const rows = table.getRowModel().rows;\n  const displayRowIndex = rows.findIndex(\n    (row) => row.original === cell.row.original,\n  );\n  const rowIndex = displayRowIndex >= 0 ? displayRowIndex : originalRowIndex;\n  const columnId = cell.column.id;\n\n  const isFocused =\n    meta?.focusedCell?.rowIndex === rowIndex &&\n    meta?.focusedCell?.columnId === columnId;\n  const isEditing =\n    meta?.editingCell?.rowIndex === rowIndex &&\n    meta?.editingCell?.columnId === columnId;\n  const isSelected = meta?.getIsCellSelected?.(rowIndex, columnId) ?? false;\n\n  const cellOpts = cell.column.columnDef.meta?.cell;\n  const variant = cellOpts?.variant ?? \"text\";\n\n  switch (variant) {\n    case \"short-text\":\n      return (\n        <ShortTextCell\n          cell={cell}\n          table={table}\n          rowIndex={rowIndex}\n          columnId={columnId}\n          isEditing={isEditing}\n          isFocused={isFocused}\n          isSelected={isSelected}\n        />\n      );\n    case \"long-text\":\n      return (\n        <LongTextCell\n          cell={cell}\n          table={table}\n          rowIndex={rowIndex}\n          columnId={columnId}\n          isEditing={isEditing}\n          isFocused={isFocused}\n          isSelected={isSelected}\n        />\n      );\n    case \"number\":\n      return (\n        <NumberCell\n          cell={cell}\n          table={table}\n          rowIndex={rowIndex}\n          columnId={columnId}\n          isEditing={isEditing}\n          isFocused={isFocused}\n          isSelected={isSelected}\n        />\n      );\n    case \"select\":\n      return (\n        <SelectCell\n          cell={cell}\n          table={table}\n          rowIndex={rowIndex}\n          columnId={columnId}\n          isEditing={isEditing}\n          isFocused={isFocused}\n          isSelected={isSelected}\n        />\n      );\n    case \"multi-select\":\n      return (\n        <MultiSelectCell\n          cell={cell}\n          table={table}\n          rowIndex={rowIndex}\n          columnId={columnId}\n          isEditing={isEditing}\n          isFocused={isFocused}\n          isSelected={isSelected}\n        />\n      );\n    case \"checkbox\":\n      return (\n        <CheckboxCell\n          cell={cell}\n          table={table}\n          rowIndex={rowIndex}\n          columnId={columnId}\n          isEditing={isEditing}\n          isFocused={isFocused}\n          isSelected={isSelected}\n        />\n      );\n    case \"date\":\n      return (\n        <DateCell\n          cell={cell}\n          table={table}\n          rowIndex={rowIndex}\n          columnId={columnId}\n          isEditing={isEditing}\n          isFocused={isFocused}\n          isSelected={isSelected}\n        />\n      );\n\n    default:\n      return (\n        <ShortTextCell\n          cell={cell}\n          table={table}\n          rowIndex={rowIndex}\n          columnId={columnId}\n          isEditing={isEditing}\n          isFocused={isFocused}\n          isSelected={isSelected}\n        />\n      );\n  }\n}\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-cell.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-cell-wrapper.tsx",
      "content": "\"use client\";\n\nimport type { Cell, Table } from \"@tanstack/react-table\";\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface DataGridCellWrapperProps<TData> extends React.ComponentProps<\"div\"> {\n  cell: Cell<TData, unknown>;\n  table: Table<TData>;\n  rowIndex: number;\n  columnId: string;\n  isEditing: boolean;\n  isFocused: boolean;\n  isSelected: boolean;\n}\n\nexport function DataGridCellWrapper<TData>({\n  table,\n  rowIndex,\n  columnId,\n  isEditing,\n  isFocused,\n  isSelected,\n  className,\n  onClick: onClickProp,\n  onKeyDown: onKeyDownProp,\n  ...props\n}: DataGridCellWrapperProps<TData>) {\n  const meta = table.options.meta;\n\n  const isSearchMatch = meta?.getIsSearchMatch?.(rowIndex, columnId) ?? false;\n  const isActiveSearchMatch =\n    meta?.getIsActiveSearchMatch?.(rowIndex, columnId) ?? false;\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent<HTMLDivElement>) => {\n      if (!isEditing) {\n        event.preventDefault();\n        onClickProp?.(event);\n        if (isFocused) {\n          meta?.onCellEditingStart?.(rowIndex, columnId);\n        } else {\n          meta?.onCellClick?.(rowIndex, columnId, event);\n        }\n      }\n    },\n    [meta, rowIndex, columnId, isEditing, isFocused, onClickProp],\n  );\n\n  const onContextMenu = React.useCallback(\n    (event: React.MouseEvent) => {\n      if (!isEditing) {\n        meta?.onCellContextMenu?.(rowIndex, columnId, event);\n      }\n    },\n    [meta, rowIndex, columnId, isEditing],\n  );\n\n  const onMouseDown = React.useCallback(\n    (event: React.MouseEvent) => {\n      if (!isEditing) {\n        meta?.onCellMouseDown?.(rowIndex, columnId, event);\n      }\n    },\n    [meta, rowIndex, columnId, isEditing],\n  );\n\n  const onMouseEnter = React.useCallback(\n    (event: React.MouseEvent) => {\n      if (!isEditing) {\n        meta?.onCellMouseEnter?.(rowIndex, columnId, event);\n      }\n    },\n    [meta, rowIndex, columnId, isEditing],\n  );\n\n  const onMouseUp = React.useCallback(() => {\n    if (!isEditing) {\n      meta?.onCellMouseUp?.();\n    }\n  }, [meta, isEditing]);\n\n  const onDoubleClick = React.useCallback(\n    (event: React.MouseEvent) => {\n      if (!isEditing) {\n        event.preventDefault();\n        meta?.onCellDoubleClick?.(rowIndex, columnId);\n      }\n    },\n    [meta, rowIndex, columnId, isEditing],\n  );\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      onKeyDownProp?.(event);\n\n      if (event.defaultPrevented) return;\n\n      if (\n        event.key === \"ArrowUp\" ||\n        event.key === \"ArrowDown\" ||\n        event.key === \"ArrowLeft\" ||\n        event.key === \"ArrowRight\" ||\n        event.key === \"Home\" ||\n        event.key === \"End\" ||\n        event.key === \"PageUp\" ||\n        event.key === \"PageDown\" ||\n        event.key === \"Tab\"\n      ) {\n        return;\n      }\n\n      if (isFocused && !isEditing) {\n        if (event.key === \"F2\" || event.key === \"Enter\") {\n          event.preventDefault();\n          event.stopPropagation();\n          meta?.onCellEditingStart?.(rowIndex, columnId);\n          return;\n        }\n\n        if (event.key === \" \") {\n          event.preventDefault();\n          event.stopPropagation();\n          meta?.onCellEditingStart?.(rowIndex, columnId);\n          return;\n        }\n\n        if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {\n          event.preventDefault();\n          event.stopPropagation();\n          meta?.onCellEditingStart?.(rowIndex, columnId);\n        }\n      }\n    },\n    [onKeyDownProp, isFocused, isEditing, meta, rowIndex, columnId],\n  );\n\n  const rowHeight = meta?.rowHeight ?? \"short\";\n\n  return (\n    <div\n      role=\"button\"\n      data-slot=\"grid-cell-wrapper\"\n      data-editing={isEditing ? \"\" : undefined}\n      data-focused={isFocused ? \"\" : undefined}\n      data-selected={isSelected ? \"\" : undefined}\n      tabIndex={isFocused && !isEditing ? 0 : -1}\n      className={cn(\n        \"size-full px-2 py-1.5 text-left text-sm outline-none has-data-[slot=checkbox]:pt-2.5\",\n        {\n          \"ring-1 ring-ring ring-inset\": isFocused,\n          \"bg-yellow-100 dark:bg-yellow-900/30\":\n            isSearchMatch && !isActiveSearchMatch,\n          \"bg-orange-200 dark:bg-orange-900/50\": isActiveSearchMatch,\n          \"bg-primary/10\": isSelected && !isEditing,\n          \"cursor-default\": !isEditing,\n          \"**:data-[slot=grid-cell-content]:line-clamp-1\":\n            !isEditing && rowHeight === \"short\",\n          \"**:data-[slot=grid-cell-content]:line-clamp-2\":\n            !isEditing && rowHeight === \"medium\",\n          \"**:data-[slot=grid-cell-content]:line-clamp-3\":\n            !isEditing && rowHeight === \"tall\",\n          \"**:data-[slot=grid-cell-content]:line-clamp-4\":\n            !isEditing && rowHeight === \"extra-tall\",\n        },\n        className,\n      )}\n      onClick={onClick}\n      onContextMenu={onContextMenu}\n      onDoubleClick={onDoubleClick}\n      onMouseDown={onMouseDown}\n      onMouseEnter={onMouseEnter}\n      onMouseUp={onMouseUp}\n      onKeyDown={onKeyDown}\n      {...props}\n    />\n  );\n}\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-cell-wrapper.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-cell-variants.tsx",
      "content": "\"use client\";\n\nimport type { Cell, Table } from \"@tanstack/react-table\";\nimport { Check, X } from \"lucide-react\";\nimport * as React from \"react\";\nimport { DataGridCellWrapper } from \"@/components/data-grid/data-grid-cell-wrapper\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Calendar } from \"@/components/ui/calendar\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n  CommandSeparator,\n} from \"@/components/ui/command\";\nimport {\n  Popover,\n  PopoverAnchor,\n  PopoverContent,\n} from \"@/components/ui/popover\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { useDebouncedCallback } from \"@/hooks/use-debounced-callback\";\nimport { getLineCount } from \"@/lib/data-grid\";\nimport { cn } from \"@/lib/utils\";\n\ninterface CellVariantProps<TData> {\n  cell: Cell<TData, unknown>;\n  table: Table<TData>;\n  rowIndex: number;\n  columnId: string;\n  isEditing: boolean;\n  isFocused: boolean;\n  isSelected: boolean;\n}\n\nexport function ShortTextCell<TData>({\n  cell,\n  table,\n  rowIndex,\n  columnId,\n  isEditing,\n  isFocused,\n  isSelected,\n}: CellVariantProps<TData>) {\n  const initialValue = cell.getValue() as string;\n  const [value, setValue] = React.useState(initialValue);\n  const cellRef = React.useRef<HTMLDivElement>(null);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const meta = table.options.meta;\n\n  const onBlur = React.useCallback(() => {\n    // Read the current value directly from the DOM to avoid stale state\n    const currentValue = cellRef.current?.textContent ?? \"\";\n    if (currentValue !== initialValue) {\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: currentValue });\n    }\n    meta?.onCellEditingStop?.();\n  }, [meta, rowIndex, columnId, initialValue]);\n\n  const onInput = React.useCallback(\n    (event: React.FormEvent<HTMLDivElement>) => {\n      const currentValue = event.currentTarget.textContent ?? \"\";\n      setValue(currentValue);\n    },\n    [],\n  );\n\n  const onWrapperKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (isEditing) {\n        if (event.key === \"Enter\") {\n          event.preventDefault();\n          const currentValue = cellRef.current?.textContent ?? \"\";\n          if (currentValue !== initialValue) {\n            meta?.onDataUpdate?.({ rowIndex, columnId, value: currentValue });\n          }\n          meta?.onCellEditingStop?.({ moveToNextRow: true });\n        } else if (event.key === \"Tab\") {\n          event.preventDefault();\n          const currentValue = cellRef.current?.textContent ?? \"\";\n          if (currentValue !== initialValue) {\n            meta?.onDataUpdate?.({ rowIndex, columnId, value: currentValue });\n          }\n          meta?.onCellEditingStop?.({\n            direction: event.shiftKey ? \"left\" : \"right\",\n          });\n        } else if (event.key === \"Escape\") {\n          event.preventDefault();\n          setValue(initialValue);\n          cellRef.current?.blur();\n        }\n      } else if (\n        isFocused &&\n        event.key.length === 1 &&\n        !event.ctrlKey &&\n        !event.metaKey\n      ) {\n        // Handle typing to pre-fill the value when editing starts\n        setValue(event.key);\n\n        queueMicrotask(() => {\n          if (cellRef.current && cellRef.current.contentEditable === \"true\") {\n            cellRef.current.textContent = event.key;\n            const range = document.createRange();\n            const selection = window.getSelection();\n            range.selectNodeContents(cellRef.current);\n            range.collapse(false);\n            selection?.removeAllRanges();\n            selection?.addRange(range);\n          }\n        });\n      }\n    },\n    [isEditing, isFocused, initialValue, meta, rowIndex, columnId],\n  );\n\n  React.useEffect(() => {\n    setValue(initialValue);\n    if (cellRef.current && !isEditing) {\n      cellRef.current.textContent = initialValue;\n    }\n  }, [initialValue, isEditing]);\n\n  React.useEffect(() => {\n    if (isEditing && cellRef.current) {\n      cellRef.current.focus();\n\n      if (!cellRef.current.textContent && value) {\n        cellRef.current.textContent = value;\n      }\n\n      if (cellRef.current.textContent) {\n        const range = document.createRange();\n        const selection = window.getSelection();\n        range.selectNodeContents(cellRef.current);\n        range.collapse(false);\n        selection?.removeAllRanges();\n        selection?.addRange(range);\n      }\n    }\n    // Don't focus if we're in the middle of a scroll operation\n    if (\n      isFocused &&\n      !isEditing &&\n      !meta?.searchOpen &&\n      !meta?.isScrolling &&\n      containerRef.current\n    ) {\n      containerRef.current.focus();\n    }\n  }, [isFocused, isEditing, value, meta?.searchOpen, meta?.isScrolling]);\n\n  const displayValue = !isEditing ? (value ?? \"\") : \"\";\n\n  return (\n    <DataGridCellWrapper\n      ref={containerRef}\n      cell={cell}\n      table={table}\n      rowIndex={rowIndex}\n      columnId={columnId}\n      isEditing={isEditing}\n      isFocused={isFocused}\n      isSelected={isSelected}\n      onKeyDown={onWrapperKeyDown}\n    >\n      <div\n        role=\"textbox\"\n        data-slot=\"grid-cell-content\"\n        contentEditable={isEditing}\n        tabIndex={-1}\n        ref={cellRef}\n        onBlur={onBlur}\n        onInput={onInput}\n        suppressContentEditableWarning\n        className={cn(\"size-full overflow-hidden outline-none\", {\n          \"whitespace-nowrap [&_*]:inline [&_*]:whitespace-nowrap [&_br]:hidden\":\n            isEditing,\n        })}\n      >\n        {displayValue}\n      </div>\n    </DataGridCellWrapper>\n  );\n}\n\nexport function LongTextCell<TData>({\n  cell,\n  table,\n  rowIndex,\n  columnId,\n  isFocused,\n  isEditing,\n  isSelected,\n}: CellVariantProps<TData>) {\n  const initialValue = cell.getValue() as string;\n  const [value, setValue] = React.useState(initialValue ?? \"\");\n  const [open, setOpen] = React.useState(false);\n  const textareaRef = React.useRef<HTMLTextAreaElement>(null);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const meta = table.options.meta;\n  const sideOffset = -(containerRef.current?.clientHeight ?? 0);\n\n  const prevInitialValueRef = React.useRef(initialValue);\n  if (initialValue !== prevInitialValueRef.current) {\n    prevInitialValueRef.current = initialValue;\n    setValue(initialValue ?? \"\");\n  }\n\n  // Debounced auto-save (300ms delay)\n  const debouncedSave = useDebouncedCallback((newValue: string) => {\n    meta?.onDataUpdate?.({ rowIndex, columnId, value: newValue });\n  }, 300);\n\n  const onSave = React.useCallback(() => {\n    // Immediately save any pending changes and close the popover\n    if (value !== initialValue) {\n      meta?.onDataUpdate?.({ rowIndex, columnId, value });\n    }\n    setOpen(false);\n    meta?.onCellEditingStop?.();\n  }, [meta, value, initialValue, rowIndex, columnId]);\n\n  const onCancel = React.useCallback(() => {\n    // Restore the original value\n    setValue(initialValue ?? \"\");\n    meta?.onDataUpdate?.({ rowIndex, columnId, value: initialValue });\n    setOpen(false);\n    meta?.onCellEditingStop?.();\n  }, [meta, initialValue, rowIndex, columnId]);\n\n  const onChange = React.useCallback(\n    (event: React.ChangeEvent<HTMLTextAreaElement>) => {\n      const newValue = event.target.value;\n      setValue(newValue);\n      // Debounced auto-save\n      debouncedSave(newValue);\n    },\n    [debouncedSave],\n  );\n\n  const onOpenChange = React.useCallback(\n    (isOpen: boolean) => {\n      setOpen(isOpen);\n      if (!isOpen) {\n        // Immediately save any pending changes when closing\n        if (value !== initialValue) {\n          meta?.onDataUpdate?.({ rowIndex, columnId, value });\n        }\n        meta?.onCellEditingStop?.();\n      }\n    },\n    [meta, value, initialValue, rowIndex, columnId],\n  );\n\n  const onOpenAutoFocus: NonNullable<\n    React.ComponentProps<typeof PopoverContent>[\"onOpenAutoFocus\"]\n  > = React.useCallback((event) => {\n    event.preventDefault();\n    if (textareaRef.current) {\n      textareaRef.current.focus();\n      const length = textareaRef.current.value.length;\n      textareaRef.current.setSelectionRange(length, length);\n    }\n  }, []);\n\n  const onWrapperKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (isEditing && !open) {\n        if (event.key === \"Escape\") {\n          event.preventDefault();\n          meta?.onCellEditingStop?.();\n        } else if (event.key === \"Tab\") {\n          event.preventDefault();\n          // Save any pending changes\n          if (value !== initialValue) {\n            meta?.onDataUpdate?.({ rowIndex, columnId, value });\n          }\n          meta?.onCellEditingStop?.({\n            direction: event.shiftKey ? \"left\" : \"right\",\n          });\n        }\n      }\n    },\n    [isEditing, open, meta, value, initialValue, rowIndex, columnId],\n  );\n\n  const onTextareaKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLTextAreaElement>) => {\n      if (event.key === \"Escape\") {\n        event.preventDefault();\n        onCancel();\n      } else if (event.key === \"Enter\" && (event.ctrlKey || event.metaKey)) {\n        event.preventDefault();\n        onSave();\n      }\n      // Stop propagation to prevent grid navigation\n      event.stopPropagation();\n    },\n    [onCancel, onSave],\n  );\n\n  const onTextareaBlur = React.useCallback(() => {\n    // Immediately save any pending changes on blur\n    if (value !== initialValue) {\n      meta?.onDataUpdate?.({ rowIndex, columnId, value });\n    }\n    setOpen(false);\n    meta?.onCellEditingStop?.();\n  }, [meta, value, initialValue, rowIndex, columnId]);\n\n  React.useEffect(() => {\n    if (isEditing && !open) {\n      setOpen(true);\n    }\n    if (\n      isFocused &&\n      !isEditing &&\n      !meta?.searchOpen &&\n      !meta?.isScrolling &&\n      containerRef.current\n    ) {\n      containerRef.current.focus();\n    }\n  }, [isFocused, isEditing, open, meta?.searchOpen, meta?.isScrolling]);\n\n  return (\n    <Popover open={open} onOpenChange={onOpenChange}>\n      <PopoverAnchor asChild>\n        <DataGridCellWrapper\n          ref={containerRef}\n          cell={cell}\n          table={table}\n          rowIndex={rowIndex}\n          columnId={columnId}\n          isEditing={isEditing}\n          isFocused={isFocused}\n          isSelected={isSelected}\n          onKeyDown={onWrapperKeyDown}\n        >\n          <span data-slot=\"grid-cell-content\">{value}</span>\n        </DataGridCellWrapper>\n      </PopoverAnchor>\n      <PopoverContent\n        data-grid-cell-editor=\"\"\n        align=\"start\"\n        side=\"bottom\"\n        sideOffset={sideOffset}\n        className=\"w-[400px] rounded-none p-0\"\n        onOpenAutoFocus={onOpenAutoFocus}\n      >\n        <Textarea\n          ref={textareaRef}\n          value={value}\n          onChange={onChange}\n          onKeyDown={onTextareaKeyDown}\n          onBlur={onTextareaBlur}\n          className=\"min-h-[150px] resize-none rounded-none border-0 shadow-none focus-visible:ring-0\"\n          placeholder=\"Enter text...\"\n        />\n      </PopoverContent>\n    </Popover>\n  );\n}\n\nexport function NumberCell<TData>({\n  cell,\n  table,\n  rowIndex,\n  columnId,\n  isFocused,\n  isEditing,\n  isSelected,\n}: CellVariantProps<TData>) {\n  const initialValue = cell.getValue() as number;\n  const [value, setValue] = React.useState(String(initialValue ?? \"\"));\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const meta = table.options.meta;\n  const cellOpts = cell.column.columnDef.meta?.cell;\n  const min = cellOpts?.variant === \"number\" ? cellOpts.min : undefined;\n  const max = cellOpts?.variant === \"number\" ? cellOpts.max : undefined;\n  const step = cellOpts?.variant === \"number\" ? cellOpts.step : undefined;\n\n  const onBlur = React.useCallback(() => {\n    const numValue = value === \"\" ? null : Number(value);\n    if (numValue !== initialValue) {\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: numValue });\n    }\n    meta?.onCellEditingStop?.();\n  }, [meta, rowIndex, columnId, initialValue, value]);\n\n  const onChange = React.useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      setValue(event.target.value);\n    },\n    [],\n  );\n\n  const onWrapperKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (isEditing) {\n        if (event.key === \"Enter\") {\n          event.preventDefault();\n          const numValue = value === \"\" ? null : Number(value);\n          if (numValue !== initialValue) {\n            meta?.onDataUpdate?.({ rowIndex, columnId, value: numValue });\n          }\n          meta?.onCellEditingStop?.({ moveToNextRow: true });\n        } else if (event.key === \"Tab\") {\n          event.preventDefault();\n          const numValue = value === \"\" ? null : Number(value);\n          if (numValue !== initialValue) {\n            meta?.onDataUpdate?.({ rowIndex, columnId, value: numValue });\n          }\n          meta?.onCellEditingStop?.({\n            direction: event.shiftKey ? \"left\" : \"right\",\n          });\n        } else if (event.key === \"Escape\") {\n          event.preventDefault();\n          setValue(String(initialValue ?? \"\"));\n          inputRef.current?.blur();\n        }\n      } else if (isFocused) {\n        // Handle Backspace to start editing with empty value\n        if (event.key === \"Backspace\") {\n          setValue(\"\");\n        } else if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {\n          // Handle typing to pre-fill the value when editing starts\n          setValue(event.key);\n        }\n      }\n    },\n    [isEditing, isFocused, initialValue, meta, rowIndex, columnId, value],\n  );\n\n  React.useEffect(() => {\n    setValue(String(initialValue ?? \"\"));\n  }, [initialValue]);\n\n  React.useEffect(() => {\n    if (isEditing && inputRef.current) {\n      inputRef.current.focus();\n      inputRef.current.select();\n    }\n    if (\n      isFocused &&\n      !isEditing &&\n      !meta?.searchOpen &&\n      !meta?.isScrolling &&\n      containerRef.current\n    ) {\n      containerRef.current.focus();\n    }\n  }, [isFocused, isEditing, meta?.searchOpen, meta?.isScrolling]);\n\n  return (\n    <DataGridCellWrapper\n      ref={containerRef}\n      cell={cell}\n      table={table}\n      rowIndex={rowIndex}\n      columnId={columnId}\n      isEditing={isEditing}\n      isFocused={isFocused}\n      isSelected={isSelected}\n      onKeyDown={onWrapperKeyDown}\n    >\n      {isEditing ? (\n        <input\n          ref={inputRef}\n          type=\"number\"\n          value={value}\n          min={min}\n          max={max}\n          step={step}\n          onBlur={onBlur}\n          onChange={onChange}\n          className=\"w-full border-none bg-transparent p-0 outline-none\"\n        />\n      ) : (\n        <span data-slot=\"grid-cell-content\">{value}</span>\n      )}\n    </DataGridCellWrapper>\n  );\n}\n\nexport function SelectCell<TData>({\n  cell,\n  table,\n  rowIndex,\n  columnId,\n  isFocused,\n  isEditing,\n  isSelected,\n}: CellVariantProps<TData>) {\n  const initialValue = cell.getValue() as string;\n  const [value, setValue] = React.useState(initialValue);\n  const [open, setOpen] = React.useState(false);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const meta = table.options.meta;\n  const cellOpts = cell.column.columnDef.meta?.cell;\n  const options = cellOpts?.variant === \"select\" ? cellOpts.options : [];\n\n  const onValueChange = React.useCallback(\n    (newValue: string) => {\n      setValue(newValue);\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: newValue });\n      meta?.onCellEditingStop?.();\n    },\n    [meta, rowIndex, columnId],\n  );\n\n  const onOpenChange = React.useCallback(\n    (isOpen: boolean) => {\n      setOpen(isOpen);\n      if (!isOpen) {\n        meta?.onCellEditingStop?.();\n      }\n    },\n    [meta],\n  );\n\n  const onWrapperKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (isEditing) {\n        if (event.key === \"Escape\") {\n          event.preventDefault();\n          setValue(initialValue);\n          setOpen(false);\n          meta?.onCellEditingStop?.();\n        } else if (event.key === \"Tab\") {\n          event.preventDefault();\n          setOpen(false);\n          meta?.onCellEditingStop?.({\n            direction: event.shiftKey ? \"left\" : \"right\",\n          });\n        }\n      }\n    },\n    [isEditing, initialValue, meta],\n  );\n\n  React.useEffect(() => {\n    setValue(initialValue);\n  }, [initialValue]);\n\n  React.useEffect(() => {\n    if (isEditing && !open) {\n      setOpen(true);\n    }\n    if (\n      isFocused &&\n      !isEditing &&\n      !meta?.searchOpen &&\n      !meta?.isScrolling &&\n      containerRef.current\n    ) {\n      containerRef.current.focus();\n    }\n  }, [isFocused, isEditing, open, meta?.searchOpen, meta?.isScrolling]);\n\n  const displayLabel =\n    options.find((opt) => opt.value === value)?.label ?? value;\n\n  return (\n    <DataGridCellWrapper\n      ref={containerRef}\n      cell={cell}\n      table={table}\n      rowIndex={rowIndex}\n      columnId={columnId}\n      isEditing={isEditing}\n      isFocused={isFocused}\n      isSelected={isSelected}\n      onKeyDown={onWrapperKeyDown}\n    >\n      {isEditing ? (\n        <Select\n          value={value}\n          onValueChange={onValueChange}\n          open={open}\n          onOpenChange={onOpenChange}\n        >\n          <SelectTrigger\n            size=\"sm\"\n            className=\"size-full items-start border-none p-0 shadow-none focus-visible:ring-0 dark:bg-transparent [&_svg]:hidden\"\n          >\n            <SelectValue />\n          </SelectTrigger>\n          <SelectContent\n            data-grid-cell-editor=\"\"\n            // compensate for the wrapper padding\n            align=\"start\"\n            alignOffset={-8}\n            sideOffset={-8}\n            className=\"min-w-[calc(var(--radix-select-trigger-width)+16px)]\"\n          >\n            {options.map((option) => (\n              <SelectItem key={option.value} value={option.value}>\n                {option.label}\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      ) : (\n        <span data-slot=\"grid-cell-content\">{displayLabel}</span>\n      )}\n    </DataGridCellWrapper>\n  );\n}\n\nexport function MultiSelectCell<TData>({\n  cell,\n  table,\n  rowIndex,\n  columnId,\n  isFocused,\n  isEditing,\n  isSelected,\n}: CellVariantProps<TData>) {\n  const cellValue = React.useMemo(\n    () => (cell.getValue() as string[]) ?? [],\n    [cell],\n  );\n\n  const cellId = `${rowIndex}-${columnId}`;\n  const prevCellIdRef = React.useRef(cellId);\n\n  const [selectedValues, setSelectedValues] =\n    React.useState<string[]>(cellValue);\n  const [open, setOpen] = React.useState(false);\n  const [searchValue, setSearchValue] = React.useState(\"\");\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const meta = table.options.meta;\n  const cellOpts = cell.column.columnDef.meta?.cell;\n  const options = cellOpts?.variant === \"multi-select\" ? cellOpts.options : [];\n  const sideOffset = -(containerRef.current?.clientHeight ?? 0);\n\n  if (prevCellIdRef.current !== cellId) {\n    prevCellIdRef.current = cellId;\n    setSelectedValues(cellValue);\n    setOpen(false);\n    setSearchValue(\"\");\n  }\n\n  const onValueChange = React.useCallback(\n    (value: string) => {\n      const newValues = selectedValues.includes(value)\n        ? selectedValues.filter((v) => v !== value)\n        : [...selectedValues, value];\n\n      setSelectedValues(newValues);\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: newValues });\n      // Clear search input and focus back on input after selection\n      setSearchValue(\"\");\n      queueMicrotask(() => inputRef.current?.focus());\n    },\n    [selectedValues, meta, rowIndex, columnId],\n  );\n\n  const removeValue = React.useCallback(\n    (valueToRemove: string, event?: React.MouseEvent) => {\n      event?.stopPropagation();\n      event?.preventDefault();\n      const newValues = selectedValues.filter((v) => v !== valueToRemove);\n      setSelectedValues(newValues);\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: newValues });\n      // Focus back on input after removing\n      setTimeout(() => inputRef.current?.focus(), 0);\n    },\n    [selectedValues, meta, rowIndex, columnId],\n  );\n\n  const clearAll = React.useCallback(() => {\n    setSelectedValues([]);\n    meta?.onDataUpdate?.({ rowIndex, columnId, value: [] });\n    queueMicrotask(() => inputRef.current?.focus());\n  }, [meta, rowIndex, columnId]);\n\n  const onOpenChange = React.useCallback(\n    (isOpen: boolean) => {\n      setOpen(isOpen);\n      if (!isOpen) {\n        setSearchValue(\"\");\n        meta?.onCellEditingStop?.();\n      }\n    },\n    [meta],\n  );\n\n  const onOpenAutoFocus: NonNullable<\n    React.ComponentProps<typeof PopoverContent>[\"onOpenAutoFocus\"]\n  > = React.useCallback((event) => {\n    event.preventDefault();\n    inputRef.current?.focus();\n  }, []);\n\n  const onWrapperKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (isEditing) {\n        if (event.key === \"Escape\") {\n          event.preventDefault();\n          setSelectedValues(cellValue);\n          setSearchValue(\"\");\n          setOpen(false);\n          meta?.onCellEditingStop?.();\n        } else if (event.key === \"Tab\") {\n          event.preventDefault();\n          setSearchValue(\"\");\n          setOpen(false);\n          meta?.onCellEditingStop?.({\n            direction: event.shiftKey ? \"left\" : \"right\",\n          });\n        }\n      }\n    },\n    [isEditing, cellValue, meta],\n  );\n\n  const onInputKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLInputElement>) => {\n      // Handle backspace when input is empty - remove last selected item\n      if (\n        event.key === \"Backspace\" &&\n        searchValue === \"\" &&\n        selectedValues.length > 0\n      ) {\n        event.preventDefault();\n        const lastValue = selectedValues[selectedValues.length - 1];\n        if (lastValue) {\n          removeValue(lastValue);\n        }\n      }\n      // Prevent escape from propagating to close the popover immediately\n      // Let the command handle it first\n      if (event.key === \"Escape\") {\n        event.stopPropagation();\n      }\n    },\n    [searchValue, selectedValues, removeValue],\n  );\n\n  React.useEffect(() => {\n    if (isEditing && !open) {\n      setOpen(true);\n    }\n    if (\n      isFocused &&\n      !isEditing &&\n      !meta?.searchOpen &&\n      !meta?.isScrolling &&\n      containerRef.current\n    ) {\n      containerRef.current.focus();\n    }\n  }, [isFocused, isEditing, open, meta?.searchOpen, meta?.isScrolling]);\n\n  // Focus input when popover opens\n  React.useEffect(() => {\n    if (open && inputRef.current) {\n      setTimeout(() => inputRef.current?.focus(), 0);\n    }\n  }, [open]);\n\n  const displayLabels = selectedValues\n    .map((val) => options.find((opt) => opt.value === val)?.label ?? val)\n    .filter(Boolean);\n\n  const rowHeight = table.options.meta?.rowHeight ?? \"short\";\n\n  const lineCount = getLineCount(rowHeight);\n  const maxVisibleBadgeCount = lineCount * 3;\n\n  const visibleLabels = displayLabels.slice(0, maxVisibleBadgeCount);\n  const hiddenBadgeCount = Math.max(\n    0,\n    displayLabels.length - maxVisibleBadgeCount,\n  );\n\n  return (\n    <DataGridCellWrapper\n      ref={containerRef}\n      cell={cell}\n      table={table}\n      rowIndex={rowIndex}\n      columnId={columnId}\n      isEditing={isEditing}\n      isFocused={isFocused}\n      isSelected={isSelected}\n      onKeyDown={onWrapperKeyDown}\n    >\n      {isEditing ? (\n        <Popover open={open} onOpenChange={onOpenChange}>\n          <PopoverAnchor asChild>\n            <div className=\"absolute inset-0\" />\n          </PopoverAnchor>\n          <PopoverContent\n            data-grid-cell-editor=\"\"\n            align=\"start\"\n            sideOffset={sideOffset}\n            className=\"w-[300px] rounded-none p-0\"\n            onOpenAutoFocus={onOpenAutoFocus}\n          >\n            <Command className=\"[&_[data-slot=command-input-wrapper]]:h-auto [&_[data-slot=command-input-wrapper]]:border-none [&_[data-slot=command-input-wrapper]]:p-0 [&_[data-slot=command-input-wrapper]_svg]:hidden\">\n              <div className=\"flex min-h-9 flex-wrap items-center gap-1 border-b px-3 py-1.5\">\n                {selectedValues.map((value) => {\n                  const option = options.find((opt) => opt.value === value);\n                  const label = option?.label ?? value;\n\n                  return (\n                    <Badge\n                      key={value}\n                      variant=\"secondary\"\n                      className=\"h-5 gap-1 px-1.5 text-xs\"\n                    >\n                      {label}\n                      <button\n                        type=\"button\"\n                        onClick={(event) => removeValue(value, event)}\n                        onPointerDown={(event) => {\n                          event.preventDefault();\n                          event.stopPropagation();\n                        }}\n                      >\n                        <X className=\"size-3\" />\n                      </button>\n                    </Badge>\n                  );\n                })}\n                <CommandInput\n                  ref={inputRef}\n                  value={searchValue}\n                  onValueChange={setSearchValue}\n                  onKeyDown={onInputKeyDown}\n                  placeholder=\"Search...\"\n                  className=\"h-auto flex-1 p-0\"\n                />\n              </div>\n              <CommandList className=\"max-h-full\">\n                <CommandEmpty>No options found.</CommandEmpty>\n                <CommandGroup className=\"max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden\">\n                  {options.map((option) => {\n                    const isSelected = selectedValues.includes(option.value);\n\n                    return (\n                      <CommandItem\n                        key={option.value}\n                        value={option.label}\n                        onSelect={() => onValueChange(option.value)}\n                      >\n                        <div\n                          className={cn(\n                            \"flex size-4 items-center justify-center rounded-sm border border-primary\",\n                            isSelected\n                              ? \"bg-primary text-primary-foreground\"\n                              : \"opacity-50 [&_svg]:invisible\",\n                          )}\n                        >\n                          <Check className=\"size-3\" />\n                        </div>\n                        <span>{option.label}</span>\n                      </CommandItem>\n                    );\n                  })}\n                </CommandGroup>\n                {selectedValues.length > 0 && (\n                  <>\n                    <CommandSeparator />\n                    <CommandGroup>\n                      <CommandItem\n                        onSelect={clearAll}\n                        className=\"justify-center text-muted-foreground\"\n                      >\n                        Clear all\n                      </CommandItem>\n                    </CommandGroup>\n                  </>\n                )}\n              </CommandList>\n            </Command>\n          </PopoverContent>\n        </Popover>\n      ) : null}\n      {displayLabels.length > 0 ? (\n        <div className=\"flex flex-wrap items-center gap-1 overflow-hidden\">\n          {visibleLabels.map((label, index) => (\n            <Badge\n              key={selectedValues[index]}\n              variant=\"secondary\"\n              className=\"h-5 shrink-0 px-1.5 text-xs\"\n            >\n              {label}\n            </Badge>\n          ))}\n          {hiddenBadgeCount > 0 && (\n            <Badge\n              variant=\"outline\"\n              className=\"h-5 shrink-0 px-1.5 text-muted-foreground text-xs\"\n            >\n              +{hiddenBadgeCount}\n            </Badge>\n          )}\n        </div>\n      ) : null}\n    </DataGridCellWrapper>\n  );\n}\n\nexport function CheckboxCell<TData>({\n  cell,\n  table,\n  rowIndex,\n  columnId,\n  isFocused,\n  isSelected,\n}: CellVariantProps<TData>) {\n  const initialValue = cell.getValue() as boolean;\n  const [value, setValue] = React.useState(Boolean(initialValue));\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const meta = table.options.meta;\n\n  const onCheckedChange = React.useCallback(\n    (checked: boolean) => {\n      setValue(checked);\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: checked });\n    },\n    [meta, rowIndex, columnId],\n  );\n\n  const onWrapperKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (isFocused && (event.key === \" \" || event.key === \"Enter\")) {\n        event.preventDefault();\n        event.stopPropagation();\n        onCheckedChange(!value);\n      }\n    },\n    [isFocused, value, onCheckedChange],\n  );\n\n  React.useEffect(() => {\n    setValue(Boolean(initialValue));\n  }, [initialValue]);\n\n  React.useEffect(() => {\n    if (\n      isFocused &&\n      !meta?.searchOpen &&\n      !meta?.isScrolling &&\n      containerRef.current\n    ) {\n      containerRef.current.focus();\n    }\n  }, [isFocused, meta?.searchOpen, meta?.isScrolling]);\n\n  const onWrapperClick = React.useCallback(\n    (event: React.MouseEvent) => {\n      if (isFocused) {\n        event.preventDefault();\n        event.stopPropagation();\n        onCheckedChange(!value);\n      }\n    },\n    [isFocused, value, onCheckedChange],\n  );\n\n  const onCheckboxClick = React.useCallback((event: React.MouseEvent) => {\n    event.stopPropagation();\n  }, []);\n\n  const onCheckboxMouseDown = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      event.stopPropagation();\n    },\n    [],\n  );\n\n  const onCheckboxDoubleClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      event.stopPropagation();\n    },\n    [],\n  );\n\n  return (\n    <DataGridCellWrapper\n      ref={containerRef}\n      cell={cell}\n      table={table}\n      rowIndex={rowIndex}\n      columnId={columnId}\n      isEditing={false}\n      isFocused={isFocused}\n      isSelected={isSelected}\n      onClick={onWrapperClick}\n      onKeyDown={onWrapperKeyDown}\n      className=\"flex size-full justify-center\"\n    >\n      <Checkbox\n        checked={value}\n        onCheckedChange={onCheckedChange}\n        onClick={onCheckboxClick}\n        onMouseDown={onCheckboxMouseDown}\n        onDoubleClick={onCheckboxDoubleClick}\n        className=\"border-primary\"\n      />\n    </DataGridCellWrapper>\n  );\n}\n\nfunction formatDateForDisplay(dateStr: string) {\n  if (!dateStr) return \"\";\n  const date = new Date(dateStr);\n  return date.toLocaleDateString();\n}\n\nexport function DateCell<TData>({\n  cell,\n  table,\n  rowIndex,\n  columnId,\n  isFocused,\n  isEditing,\n  isSelected,\n}: CellVariantProps<TData>) {\n  const initialValue = cell.getValue() as string;\n  const [value, setValue] = React.useState(initialValue ?? \"\");\n  const [open, setOpen] = React.useState(false);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const meta = table.options.meta;\n\n  const prevInitialValueRef = React.useRef(initialValue);\n  if (initialValue !== prevInitialValueRef.current) {\n    prevInitialValueRef.current = initialValue;\n    setValue(initialValue ?? \"\");\n  }\n\n  const selectedDate = value ? new Date(value) : undefined;\n\n  const onDateSelect = React.useCallback(\n    (date: Date | undefined) => {\n      if (!date) return;\n\n      const formattedDate = date.toISOString().split(\"T\")[0] ?? \"\";\n      setValue(formattedDate);\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: formattedDate });\n      setOpen(false);\n      meta?.onCellEditingStop?.();\n    },\n    [meta, rowIndex, columnId],\n  );\n\n  const onOpenChange = React.useCallback(\n    (isOpen: boolean) => {\n      setOpen(isOpen);\n      if (!isOpen && isEditing) {\n        meta?.onCellEditingStop?.();\n      }\n    },\n    [isEditing, meta],\n  );\n\n  const onWrapperKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (isEditing) {\n        if (event.key === \"Escape\") {\n          event.preventDefault();\n          setValue(initialValue);\n          setOpen(false);\n        } else if (event.key === \"Tab\") {\n          event.preventDefault();\n          setOpen(false);\n          meta?.onCellEditingStop?.({\n            direction: event.shiftKey ? \"left\" : \"right\",\n          });\n        }\n      }\n    },\n    [isEditing, initialValue, meta],\n  );\n\n  React.useEffect(() => {\n    if (isEditing) {\n      setOpen(true);\n    } else {\n      setOpen(false);\n    }\n  }, [isEditing]);\n\n  React.useEffect(() => {\n    if (\n      isFocused &&\n      !isEditing &&\n      !meta?.searchOpen &&\n      !meta?.isScrolling &&\n      containerRef.current\n    ) {\n      containerRef.current.focus();\n    }\n  }, [isFocused, isEditing, meta?.searchOpen, meta?.isScrolling]);\n\n  return (\n    <DataGridCellWrapper\n      ref={containerRef}\n      cell={cell}\n      table={table}\n      rowIndex={rowIndex}\n      columnId={columnId}\n      isEditing={isEditing}\n      isFocused={isFocused}\n      isSelected={isSelected}\n      onKeyDown={onWrapperKeyDown}\n    >\n      <Popover open={open} onOpenChange={onOpenChange}>\n        <PopoverAnchor asChild>\n          <span data-slot=\"grid-cell-content\">\n            {formatDateForDisplay(value)}\n          </span>\n        </PopoverAnchor>\n        {isEditing && (\n          <PopoverContent\n            data-grid-cell-editor=\"\"\n            align=\"start\"\n            sideOffset={10}\n            className=\"w-auto p-0\"\n          >\n            <Calendar\n              autoFocus\n              captionLayout=\"dropdown\"\n              mode=\"single\"\n              className=\"rounded-md border shadow-sm\"\n              defaultMonth={selectedDate ?? new Date()}\n              selected={selectedDate}\n              onSelect={onDateSelect}\n            />\n          </PopoverContent>\n        )}\n      </Popover>\n    </DataGridCellWrapper>\n  );\n}\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-cell-variants.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-column-header.tsx",
      "content": "\"use client\";\n\nimport type {\n  ColumnSort,\n  Header,\n  SortDirection,\n  SortingState,\n  Table,\n} from \"@tanstack/react-table\";\nimport {\n  BaselineIcon,\n  CalendarIcon,\n  CheckSquareIcon,\n  ChevronDownIcon,\n  ChevronUpIcon,\n  EyeOffIcon,\n  HashIcon,\n  ListChecksIcon,\n  ListIcon,\n  PinIcon,\n  PinOffIcon,\n  TextInitialIcon,\n  XIcon,\n} from \"lucide-react\";\nimport * as React from \"react\";\n\nimport {\n  DropdownMenu,\n  DropdownMenuCheckboxItem,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { cn } from \"@/lib/utils\";\nimport type { Cell } from \"@/types/data-grid\";\n\nfunction getColumnVariant(variant?: Cell[\"variant\"]): {\n  icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;\n  label: string;\n} | null {\n  switch (variant) {\n    case \"short-text\":\n      return { icon: BaselineIcon, label: \"Short text\" };\n    case \"long-text\":\n      return { icon: TextInitialIcon, label: \"Long text\" };\n    case \"number\":\n      return { icon: HashIcon, label: \"Number\" };\n    case \"select\":\n      return { icon: ListIcon, label: \"Select\" };\n    case \"multi-select\":\n      return { icon: ListChecksIcon, label: \"Multi-select\" };\n    case \"checkbox\":\n      return { icon: CheckSquareIcon, label: \"Checkbox\" };\n    case \"date\":\n      return { icon: CalendarIcon, label: \"Date\" };\n    default:\n      return null;\n  }\n}\n\ninterface DataGridColumnHeaderProps<TData, TValue>\n  extends React.ComponentProps<typeof DropdownMenuTrigger> {\n  header: Header<TData, TValue>;\n  table: Table<TData>;\n}\n\nexport function DataGridColumnHeader<TData, TValue>({\n  header,\n  table,\n  className,\n  onPointerDown,\n  ...props\n}: DataGridColumnHeaderProps<TData, TValue>) {\n  const column = header.column;\n  const label = column.columnDef.meta?.label\n    ? column.columnDef.meta.label\n    : typeof column.columnDef.header === \"string\"\n      ? column.columnDef.header\n      : column.id;\n\n  const isAnyColumnResizing =\n    table.getState().columnSizingInfo.isResizingColumn;\n\n  const cellVariant = column.columnDef.meta?.cell;\n  const columnVariant = getColumnVariant(cellVariant?.variant);\n\n  const pinnedPosition = column.getIsPinned();\n  const isPinnedLeft = pinnedPosition === \"left\";\n  const isPinnedRight = pinnedPosition === \"right\";\n\n  const onSortingChange = React.useCallback(\n    (direction: SortDirection) => {\n      table.setSorting((prev: SortingState) => {\n        const existingSortIndex = prev.findIndex(\n          (sort) => sort.id === column.id,\n        );\n        const newSort: ColumnSort = {\n          id: column.id,\n          desc: direction === \"desc\",\n        };\n\n        if (existingSortIndex >= 0) {\n          const updated = [...prev];\n          updated[existingSortIndex] = newSort;\n          return updated;\n        } else {\n          return [...prev, newSort];\n        }\n      });\n    },\n    [column.id, table],\n  );\n\n  const onSortRemove = React.useCallback(() => {\n    table.setSorting((prev: SortingState) =>\n      prev.filter((sort) => sort.id !== column.id),\n    );\n  }, [column.id, table]);\n\n  const onLeftPin = React.useCallback(() => {\n    column.pin(\"left\");\n  }, [column]);\n\n  const onRightPin = React.useCallback(() => {\n    column.pin(\"right\");\n  }, [column]);\n\n  const onUnpin = React.useCallback(() => {\n    column.pin(false);\n  }, [column]);\n\n  const onTriggerPointerDown = React.useCallback(\n    (event: React.PointerEvent<HTMLButtonElement>) => {\n      onPointerDown?.(event);\n      if (event.defaultPrevented) return;\n\n      if (event.button !== 0) {\n        return;\n      }\n      table.options.meta?.onColumnClick?.(column.id);\n    },\n    [table.options.meta, column.id, onPointerDown],\n  );\n\n  return (\n    <>\n      <DropdownMenu>\n        <DropdownMenuTrigger\n          className={cn(\n            \"flex size-full items-center justify-between gap-2 p-2 text-sm hover:bg-accent/40 data-[state=open]:bg-accent/40 [&_svg]:size-4\",\n            isAnyColumnResizing && \"pointer-events-none\",\n            className,\n          )}\n          onPointerDown={onTriggerPointerDown}\n          {...props}\n        >\n          <div className=\"flex min-w-0 flex-1 items-center gap-1.5\">\n            {columnVariant && (\n              <Tooltip delayDuration={100}>\n                <TooltipTrigger asChild>\n                  <columnVariant.icon className=\"size-3.5 shrink-0 text-muted-foreground\" />\n                </TooltipTrigger>\n                <TooltipContent side=\"top\">\n                  <p>{columnVariant.label}</p>\n                </TooltipContent>\n              </Tooltip>\n            )}\n            <span className=\"truncate\">{label}</span>\n          </div>\n          <ChevronDownIcon className=\"shrink-0 text-muted-foreground\" />\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"start\" sideOffset={0} className=\"w-60\">\n          {column.getCanSort() && (\n            <>\n              <DropdownMenuCheckboxItem\n                className=\"relative pr-8 pl-2 [&>span:first-child]:right-2 [&>span:first-child]:left-auto [&_svg]:text-muted-foreground\"\n                checked={column.getIsSorted() === \"asc\"}\n                onClick={() => onSortingChange(\"asc\")}\n              >\n                <ChevronUpIcon />\n                Sort asc\n              </DropdownMenuCheckboxItem>\n              <DropdownMenuCheckboxItem\n                className=\"relative pr-8 pl-2 [&>span:first-child]:right-2 [&>span:first-child]:left-auto [&_svg]:text-muted-foreground\"\n                checked={column.getIsSorted() === \"desc\"}\n                onClick={() => onSortingChange(\"desc\")}\n              >\n                <ChevronDownIcon />\n                Sort desc\n              </DropdownMenuCheckboxItem>\n              {column.getIsSorted() && (\n                <DropdownMenuItem onClick={onSortRemove}>\n                  <XIcon />\n                  Remove sort\n                </DropdownMenuItem>\n              )}\n            </>\n          )}\n          {column.getCanPin() && (\n            <>\n              {column.getCanSort() && <DropdownMenuSeparator />}\n\n              {isPinnedLeft ? (\n                <DropdownMenuItem\n                  className=\"[&_svg]:text-muted-foreground\"\n                  onClick={onUnpin}\n                >\n                  <PinOffIcon />\n                  Unpin from left\n                </DropdownMenuItem>\n              ) : (\n                <DropdownMenuItem\n                  className=\"[&_svg]:text-muted-foreground\"\n                  onClick={onLeftPin}\n                >\n                  <PinIcon />\n                  Pin to left\n                </DropdownMenuItem>\n              )}\n              {isPinnedRight ? (\n                <DropdownMenuItem\n                  className=\"[&_svg]:text-muted-foreground\"\n                  onClick={onUnpin}\n                >\n                  <PinOffIcon />\n                  Unpin from right\n                </DropdownMenuItem>\n              ) : (\n                <DropdownMenuItem\n                  className=\"[&_svg]:text-muted-foreground\"\n                  onClick={onRightPin}\n                >\n                  <PinIcon />\n                  Pin to right\n                </DropdownMenuItem>\n              )}\n            </>\n          )}\n          {column.getCanHide() && (\n            <>\n              <DropdownMenuSeparator />\n              <DropdownMenuCheckboxItem\n                className=\"relative pr-8 pl-2 [&>span:first-child]:right-2 [&>span:first-child]:left-auto [&_svg]:text-muted-foreground\"\n                checked={!column.getIsVisible()}\n                onClick={() => column.toggleVisibility(false)}\n              >\n                <EyeOffIcon />\n                Hide column\n              </DropdownMenuCheckboxItem>\n            </>\n          )}\n        </DropdownMenuContent>\n      </DropdownMenu>\n      {header.column.getCanResize() && (\n        <DataGridColumnResizer header={header} table={table} label={label} />\n      )}\n    </>\n  );\n}\n\nconst DataGridColumnResizer = React.memo(\n  DataGridColumnResizerImpl,\n  (prev, next) => {\n    const prevColumn = prev.header.column;\n    const nextColumn = next.header.column;\n\n    if (\n      prevColumn.getIsResizing() !== nextColumn.getIsResizing() ||\n      prevColumn.getSize() !== nextColumn.getSize()\n    ) {\n      return false;\n    }\n\n    if (prev.label !== next.label) return false;\n\n    return true;\n  },\n) as typeof DataGridColumnResizerImpl;\n\ninterface DataGridColumnResizerProps<TData, TValue>\n  extends DataGridColumnHeaderProps<TData, TValue> {\n  label: string;\n}\n\nfunction DataGridColumnResizerImpl<TData, TValue>({\n  header,\n  table,\n  label,\n}: DataGridColumnResizerProps<TData, TValue>) {\n  const defaultColumnDef = table._getDefaultColumnDef();\n\n  const onDoubleClick = React.useCallback(() => {\n    header.column.resetSize();\n  }, [header.column]);\n\n  return (\n    <div\n      role=\"separator\"\n      aria-orientation=\"vertical\"\n      aria-label={`Resize ${label} column`}\n      aria-valuenow={header.column.getSize()}\n      aria-valuemin={defaultColumnDef.minSize}\n      aria-valuemax={defaultColumnDef.maxSize}\n      tabIndex={0}\n      className={cn(\n        \"after:-translate-x-1/2 -right-px absolute top-0 z-50 h-full w-0.5 cursor-ew-resize touch-none select-none bg-border transition-opacity after:absolute after:inset-y-0 after:left-1/2 after:h-full after:w-[18px] after:content-[''] hover:bg-primary focus:bg-primary focus:outline-none\",\n        header.column.getIsResizing()\n          ? \"bg-primary\"\n          : \"opacity-0 hover:opacity-100\",\n      )}\n      onDoubleClick={onDoubleClick}\n      onMouseDown={header.getResizeHandler()}\n      onTouchStart={header.getResizeHandler()}\n    />\n  );\n}\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-column-header.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-context-menu.tsx",
      "content": "\"use client\";\n\nimport type { Table, TableMeta } from \"@tanstack/react-table\";\nimport { CopyIcon, EraserIcon } from \"lucide-react\";\nimport * as React from \"react\";\nimport { toast } from \"sonner\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { parseCellKey } from \"@/lib/data-grid\";\nimport type { UpdateCell } from \"@/types/data-grid\";\n\ninterface DataGridContextMenuProps<TData> {\n  table: Table<TData>;\n}\n\nexport function DataGridContextMenu<TData>({\n  table,\n}: DataGridContextMenuProps<TData>) {\n  const meta = table.options.meta;\n  const contextMenu = meta?.contextMenu;\n  const onContextMenuOpenChange = meta?.onContextMenuOpenChange;\n  const selectionState = meta?.selectionState;\n  const dataGridRef = meta?.dataGridRef;\n  const onDataUpdate = meta?.onDataUpdate;\n\n  if (!contextMenu) return null;\n\n  return (\n    <ContextMenu\n      table={table}\n      dataGridRef={dataGridRef}\n      contextMenu={contextMenu}\n      onContextMenuOpenChange={onContextMenuOpenChange}\n      selectionState={selectionState}\n      onDataUpdate={onDataUpdate}\n    />\n  );\n}\n\ninterface ContextMenuProps<TData>\n  extends Pick<\n      TableMeta<TData>,\n      | \"dataGridRef\"\n      | \"onContextMenuOpenChange\"\n      | \"selectionState\"\n      | \"onDataUpdate\"\n    >,\n    Required<Pick<TableMeta<TData>, \"contextMenu\">> {\n  table: Table<TData>;\n}\n\nconst ContextMenu = React.memo(ContextMenuImpl, (prev, next) => {\n  if (prev.contextMenu.open !== next.contextMenu.open) return false;\n  if (!next.contextMenu.open) return true;\n  if (prev.contextMenu.x !== next.contextMenu.x) return false;\n  if (prev.contextMenu.y !== next.contextMenu.y) return false;\n\n  const prevSize = prev.selectionState?.selectedCells?.size ?? 0;\n  const nextSize = next.selectionState?.selectedCells?.size ?? 0;\n  if (prevSize !== nextSize) return false;\n\n  return true;\n}) as typeof ContextMenuImpl;\n\nfunction ContextMenuImpl<TData>({\n  table,\n  dataGridRef,\n  contextMenu,\n  onContextMenuOpenChange,\n  selectionState,\n  onDataUpdate,\n}: ContextMenuProps<TData>) {\n  const triggerStyle = React.useMemo<React.CSSProperties>(\n    () => ({\n      position: \"fixed\",\n      left: `${contextMenu.x}px`,\n      top: `${contextMenu.y}px`,\n      width: \"1px\",\n      height: \"1px\",\n      padding: 0,\n      margin: 0,\n      border: \"none\",\n      background: \"transparent\",\n      pointerEvents: \"none\",\n      opacity: 0,\n    }),\n    [contextMenu.x, contextMenu.y],\n  );\n\n  const onCloseAutoFocus: NonNullable<\n    React.ComponentProps<typeof DropdownMenuContent>[\"onCloseAutoFocus\"]\n  > = React.useCallback(\n    (event) => {\n      event.preventDefault();\n      dataGridRef?.current?.focus();\n    },\n    [dataGridRef],\n  );\n\n  const onCopy = React.useCallback(() => {\n    if (\n      !selectionState?.selectedCells ||\n      selectionState.selectedCells.size === 0\n    )\n      return;\n\n    const rows = table.getRowModel().rows;\n    const columnIds: string[] = [];\n\n    // Collect all unique column IDs from selected cells\n    const selectedCellsArray = Array.from(selectionState.selectedCells);\n    for (const cellKey of selectedCellsArray) {\n      const { columnId } = parseCellKey(cellKey);\n      if (columnId && !columnIds.includes(columnId)) {\n        columnIds.push(columnId);\n      }\n    }\n\n    // Build grid of selected cells\n    const cellData = new Map<string, string>();\n    for (const cellKey of selectedCellsArray) {\n      const { rowIndex, columnId } = parseCellKey(cellKey);\n      const row = rows[rowIndex];\n      if (row) {\n        const cell = row\n          .getVisibleCells()\n          .find((c) => c.column.id === columnId);\n        if (cell) {\n          const value = cell.getValue();\n          cellData.set(cellKey, String(value ?? \"\"));\n        }\n      }\n    }\n\n    // Get row indices and column indices\n    const rowIndices = new Set<number>();\n    const colIndices = new Set<number>();\n\n    for (const cellKey of selectedCellsArray) {\n      const { rowIndex, columnId } = parseCellKey(cellKey);\n      rowIndices.add(rowIndex);\n      const colIndex = columnIds.indexOf(columnId);\n      if (colIndex >= 0) {\n        colIndices.add(colIndex);\n      }\n    }\n\n    const sortedRowIndices = Array.from(rowIndices).sort((a, b) => a - b);\n    const sortedColIndices = Array.from(colIndices).sort((a, b) => a - b);\n    const sortedColumnIds = sortedColIndices.map((i) => columnIds[i]);\n\n    // Build TSV (tab-separated values)\n    const tsvData = sortedRowIndices\n      .map((rowIndex) =>\n        sortedColumnIds\n          .map((columnId) => {\n            const cellKey = `${rowIndex}:${columnId}`;\n            return cellData.get(cellKey) ?? \"\";\n          })\n          .join(\"\\t\"),\n      )\n      .join(\"\\n\");\n\n    navigator.clipboard.writeText(tsvData);\n    toast.success(\n      `${selectionState.selectedCells.size} cell${selectionState.selectedCells.size !== 1 ? \"s\" : \"\"} copied`,\n    );\n  }, [table, selectionState]);\n\n  const onClear = React.useCallback(() => {\n    if (\n      !selectionState?.selectedCells ||\n      selectionState.selectedCells.size === 0\n    )\n      return;\n\n    const updates: Array<UpdateCell> = [];\n\n    for (const cellKey of selectionState.selectedCells) {\n      const { rowIndex, columnId } = parseCellKey(cellKey);\n      updates.push({ rowIndex, columnId, value: \"\" });\n    }\n\n    onDataUpdate?.(updates);\n\n    toast.success(\n      `${updates.length} cell${updates.length !== 1 ? \"s\" : \"\"} cleared`,\n    );\n  }, [onDataUpdate, selectionState]);\n\n  return (\n    <DropdownMenu\n      open={contextMenu.open}\n      onOpenChange={onContextMenuOpenChange}\n    >\n      <DropdownMenuTrigger style={triggerStyle} />\n      <DropdownMenuContent\n        data-grid-popover=\"\"\n        align=\"start\"\n        className=\"w-48\"\n        onCloseAutoFocus={onCloseAutoFocus}\n      >\n        <DropdownMenuItem onSelect={onCopy}>\n          <CopyIcon />\n          Copy\n        </DropdownMenuItem>\n        <DropdownMenuItem onSelect={onClear}>\n          <EraserIcon />\n          Clear\n        </DropdownMenuItem>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-context-menu.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-keyboard-shortcuts.tsx",
      "content": "\"use client\";\n\nimport { SearchIcon, XIcon } from \"lucide-react\";\nimport * as React from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Input } from \"@/components/ui/input\";\nimport { Kbd, KbdGroup } from \"@/components/ui/kbd\";\nimport { Separator } from \"@/components/ui/separator\";\n\nconst SHORTCUT_KEY = \"/\";\n\ninterface ShortcutGroup {\n  title: string;\n  shortcuts: Array<{\n    keys: string[];\n    description: string;\n  }>;\n}\n\ninterface DataGridKeyboardShortcutsProps {\n  enableSearch?: boolean;\n}\n\nexport const DataGridKeyboardShortcuts = React.memo(\n  DataGridKeyboardShortcutsImpl,\n  (prev, next) => {\n    return prev.enableSearch === next.enableSearch;\n  },\n);\n\nfunction DataGridKeyboardShortcutsImpl({\n  enableSearch = false,\n}: DataGridKeyboardShortcutsProps) {\n  const [open, setOpen] = React.useState(false);\n  const [input, setInput] = React.useState(\"\");\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  const isMac =\n    typeof navigator !== \"undefined\"\n      ? /Mac|iPhone|iPad|iPod/.test(navigator.userAgent)\n      : false;\n\n  const modKey = isMac ? \"\" : \"Ctrl\";\n\n  const onOpenChange = React.useCallback((isOpen: boolean) => {\n    setOpen(isOpen);\n    if (!isOpen) {\n      setInput(\"\");\n    }\n  }, []);\n\n  const onOpenAutoFocus = React.useCallback((event: Event) => {\n    event.preventDefault();\n    inputRef.current?.focus();\n  }, []);\n\n  const onInputChange = React.useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      setInput(event.target.value);\n    },\n    [],\n  );\n\n  const shortcutGroups: ShortcutGroup[] = React.useMemo(\n    () => [\n      {\n        title: \"Navigation\",\n        shortcuts: [\n          {\n            keys: [\"\", \"\", \"\", \"\"],\n            description: \"Navigate between cells\",\n          },\n          {\n            keys: [\"Tab\"],\n            description: \"Move to next cell\",\n          },\n          {\n            keys: [\"Shift\", \"Tab\"],\n            description: \"Move to previous cell\",\n          },\n          {\n            keys: [\"Home\"],\n            description: \"Move to first column\",\n          },\n          {\n            keys: [\"End\"],\n            description: \"Move to last column\",\n          },\n          {\n            keys: [modKey, \"Home\"],\n            description: \"Move to first cell\",\n          },\n          {\n            keys: [modKey, \"End\"],\n            description: \"Move to last cell\",\n          },\n          {\n            keys: [\"PgUp\"],\n            description: \"Move up one page\",\n          },\n          {\n            keys: [\"PgDn\"],\n            description: \"Move down one page\",\n          },\n        ],\n      },\n      {\n        title: \"Selection\",\n        shortcuts: [\n          {\n            keys: [\"Shift\", \"\"],\n            description: \"Extend selection\",\n          },\n          {\n            keys: [modKey, \"A\"],\n            description: \"Select all cells\",\n          },\n          {\n            keys: [modKey, \"Click\"],\n            description: \"Toggle cell selection\",\n          },\n          {\n            keys: [\"Shift\", \"Click\"],\n            description: \"Select range\",\n          },\n          {\n            keys: [\"Esc\"],\n            description: \"Clear selection\",\n          },\n        ],\n      },\n      {\n        title: \"Editing\",\n        shortcuts: [\n          {\n            keys: [\"Enter\"],\n            description: \"Start editing cell\",\n          },\n          {\n            keys: [\"Double Click\"],\n            description: \"Start editing cell\",\n          },\n          {\n            keys: [\"Delete\"],\n            description: \"Clear selected cells\",\n          },\n          {\n            keys: [\"Backspace\"],\n            description: \"Clear selected cells\",\n          },\n        ],\n      },\n      ...(enableSearch\n        ? [\n            {\n              title: \"Search\",\n              shortcuts: [\n                {\n                  keys: [modKey, \"F\"],\n                  description: \"Open search\",\n                },\n                {\n                  keys: [\"Enter\"],\n                  description: \"Next match\",\n                },\n                {\n                  keys: [\"Shift\", \"Enter\"],\n                  description: \"Previous match\",\n                },\n                {\n                  keys: [\"Esc\"],\n                  description: \"Close search\",\n                },\n              ],\n            },\n          ]\n        : []),\n      {\n        title: \"Sorting\",\n        shortcuts: [\n          {\n            keys: [modKey, \"Shift\", \"S\"],\n            description: \"Toggle the sort menu\",\n          },\n          {\n            keys: [\"Backspace\"],\n            description: \"Remove sort (when focused)\",\n          },\n          {\n            keys: [\"Delete\"],\n            description: \"Remove sort (when focused)\",\n          },\n        ],\n      },\n      {\n        title: \"General\",\n        shortcuts: [\n          {\n            keys: [modKey, \"/\"],\n            description: \"Show keyboard shortcuts\",\n          },\n        ],\n      },\n    ],\n    [modKey, enableSearch],\n  );\n\n  const filteredGroups = React.useMemo(() => {\n    if (!input.trim()) return shortcutGroups;\n\n    const query = input.toLowerCase();\n    return shortcutGroups\n      .map((group) => ({\n        ...group,\n        shortcuts: group.shortcuts.filter(\n          (shortcut) =>\n            shortcut.description.toLowerCase().includes(query) ||\n            shortcut.keys.some((key) => key.toLowerCase().includes(query)),\n        ),\n      }))\n      .filter((group) => group.shortcuts.length > 0);\n  }, [shortcutGroups, input]);\n\n  React.useEffect(() => {\n    function onKeyDown(event: KeyboardEvent) {\n      if ((event.ctrlKey || event.metaKey) && event.key === SHORTCUT_KEY) {\n        event.preventDefault();\n        setOpen(true);\n      }\n    }\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      window.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, []);\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent\n        className=\"max-w-2xl px-0\"\n        onOpenAutoFocus={onOpenAutoFocus}\n        showCloseButton={false}\n      >\n        <DialogClose className=\"absolute top-6 right-6\" asChild>\n          <Button variant=\"ghost\" size=\"icon\" className=\"size-6\">\n            <XIcon />\n          </Button>\n        </DialogClose>\n        <DialogHeader className=\"px-6\">\n          <DialogTitle>Keyboard shortcuts</DialogTitle>\n          <DialogDescription className=\"sr-only\">\n            Use these keyboard shortcuts to navigate and interact with the data\n            grid more efficiently.\n          </DialogDescription>\n        </DialogHeader>\n        <div className=\"px-6\">\n          <div className=\"relative\">\n            <SearchIcon className=\"-translate-y-1/2 absolute top-1/2 left-3 size-3.5 text-muted-foreground\" />\n            <Input\n              ref={inputRef}\n              placeholder=\"Search shortcuts...\"\n              className=\"h-8 pl-8\"\n              value={input}\n              onChange={onInputChange}\n            />\n          </div>\n        </div>\n        <Separator className=\"mx-auto data-[orientation=horizontal]:w-[calc(100%-(--spacing(12)))]\" />\n        <div className=\"h-[40vh] overflow-y-auto px-6\">\n          {filteredGroups.length === 0 ? (\n            <div className=\"flex h-full flex-col items-center justify-center gap-3 text-center\">\n              <div className=\"flex size-10 shrink-0 items-center justify-center rounded-lg bg-muted text-foreground\">\n                <SearchIcon className=\"pointer-events-none size-6\" />\n              </div>\n              <div className=\"flex flex-col gap-1\">\n                <div className=\"font-medium text-lg tracking-tight\">\n                  No shortcuts found\n                </div>\n                <p className=\"text-muted-foreground text-sm\">\n                  Try searching for a different term.\n                </p>\n              </div>\n            </div>\n          ) : (\n            <div className=\"flex flex-col gap-6\">\n              {filteredGroups.map((shortcutGroup) => (\n                <div key={shortcutGroup.title} className=\"flex flex-col gap-2\">\n                  <h3 className=\"font-semibold text-foreground text-sm\">\n                    {shortcutGroup.title}\n                  </h3>\n                  <div className=\"divide-y divide-border rounded-md border\">\n                    {shortcutGroup.shortcuts.map((shortcut, index) => (\n                      <ShortcutCard\n                        key={index}\n                        keys={shortcut.keys}\n                        description={shortcut.description}\n                      />\n                    ))}\n                  </div>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\nfunction ShortcutCard({\n  keys,\n  description,\n}: ShortcutGroup[\"shortcuts\"][number]) {\n  return (\n    <div className=\"flex items-center gap-4 px-3 py-2\">\n      <span className=\"flex-1 text-sm\">{description}</span>\n      <KbdGroup className=\"shrink-0\">\n        {keys.map((key, index) => (\n          <React.Fragment key={key}>\n            {index > 0 && (\n              <span className=\"text-muted-foreground text-xs\">+</span>\n            )}\n            <Kbd>{key}</Kbd>\n          </React.Fragment>\n        ))}\n      </KbdGroup>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-keyboard-shortcuts.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-row.tsx",
      "content": "\"use client\";\n\nimport { flexRender, type Row } from \"@tanstack/react-table\";\nimport type { Virtualizer } from \"@tanstack/react-virtual\";\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@/lib/compose-refs\";\nimport { getRowHeightValue } from \"@/lib/data-grid\";\nimport { getCommonPinningStyles } from \"@/lib/data-table\";\nimport { cn } from \"@/lib/utils\";\nimport type { CellPosition, RowHeightValue } from \"@/types/data-grid\";\n\ninterface DataGridRowProps<TData> extends React.ComponentProps<\"div\"> {\n  row: Row<TData>;\n  rowVirtualizer: Virtualizer<HTMLDivElement, Element>;\n  virtualRowIndex: number;\n  rowMapRef: React.RefObject<Map<number, HTMLDivElement>>;\n  rowHeight: RowHeightValue;\n  focusedCell: CellPosition | null;\n}\n\nexport const DataGridRow = React.memo(DataGridRowImpl, (prev, next) => {\n  if (prev.row.id !== next.row.id) {\n    return false;\n  }\n\n  const prevRowIndex = prev.virtualRowIndex;\n  const nextRowIndex = next.virtualRowIndex;\n\n  const prevHasFocus = prev.focusedCell?.rowIndex === prevRowIndex;\n  const nextHasFocus = next.focusedCell?.rowIndex === nextRowIndex;\n\n  if (prevHasFocus !== nextHasFocus) {\n    return false;\n  }\n\n  if (nextHasFocus && prevHasFocus) {\n    const prevFocusedCol = prev.focusedCell?.columnId;\n    const nextFocusedCol = next.focusedCell?.columnId;\n    if (prevFocusedCol !== nextFocusedCol) {\n      return false;\n    }\n  }\n\n  if (next.rowVirtualizer.isScrolling) {\n    return true;\n  }\n\n  return false;\n}) as typeof DataGridRowImpl;\n\nfunction DataGridRowImpl<TData>({\n  row,\n  virtualRowIndex,\n  rowVirtualizer,\n  rowMapRef,\n  rowHeight,\n  focusedCell,\n  ref,\n  className,\n  ...props\n}: DataGridRowProps<TData>) {\n  const rowRef = useComposedRefs(ref, (node) => {\n    if (node && typeof virtualRowIndex !== \"undefined\") {\n      rowVirtualizer.measureElement(node);\n      rowMapRef.current.set(virtualRowIndex, node);\n    }\n  });\n\n  const isRowSelected = row.getIsSelected();\n\n  return (\n    <div\n      key={row.id}\n      role=\"row\"\n      aria-rowindex={virtualRowIndex + 2}\n      aria-selected={isRowSelected}\n      data-index={virtualRowIndex}\n      data-slot=\"grid-row\"\n      ref={rowRef}\n      tabIndex={-1}\n      className={cn(\"absolute flex w-full border-b\", className)}\n      style={{\n        height: `${getRowHeightValue(rowHeight)}px`,\n      }}\n      {...props}\n    >\n      {row.getVisibleCells().map((cell, colIndex) => {\n        const isCellFocused =\n          focusedCell?.rowIndex === virtualRowIndex &&\n          focusedCell?.columnId === cell.column.id;\n\n        return (\n          <div\n            key={cell.id}\n            role=\"gridcell\"\n            aria-colindex={colIndex + 1}\n            data-highlighted={isCellFocused ? \"\" : undefined}\n            data-slot=\"grid-cell\"\n            tabIndex={-1}\n            className={cn({\n              \"border-r\": cell.column.id !== \"select\",\n            })}\n            style={{\n              ...getCommonPinningStyles({ column: cell.column }),\n              width: `calc(var(--col-${cell.column.id}-size) * 1px)`,\n            }}\n          >\n            {typeof cell.column.columnDef.header === \"function\" ? (\n              <div\n                className={cn(\"size-full px-3 py-1.5\", {\n                  \"bg-primary/10\": isRowSelected,\n                })}\n              >\n                {flexRender(cell.column.columnDef.cell, cell.getContext())}\n              </div>\n            ) : (\n              flexRender(cell.column.columnDef.cell, cell.getContext())\n            )}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-row.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-search.tsx",
      "content": "\"use client\";\n\nimport { ChevronDown, ChevronUp, X } from \"lucide-react\";\nimport * as React from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { useDebouncedCallback } from \"@/hooks/use-debounced-callback\";\nimport type { SearchState } from \"@/types/data-grid\";\n\ninterface DataGridSearchProps extends SearchState {}\n\nexport const DataGridSearch = React.memo(DataGridSearchImpl, (prev, next) => {\n  if (prev.searchOpen !== next.searchOpen) return false;\n\n  if (!next.searchOpen) return true;\n\n  if (\n    prev.searchQuery !== next.searchQuery ||\n    prev.matchIndex !== next.matchIndex\n  ) {\n    return false;\n  }\n\n  if (prev.searchMatches.length !== next.searchMatches.length) return false;\n\n  for (let i = 0; i < prev.searchMatches.length; i++) {\n    const prevMatch = prev.searchMatches[i];\n    const nextMatch = next.searchMatches[i];\n\n    if (!prevMatch || !nextMatch) return false;\n\n    if (\n      prevMatch.rowIndex !== nextMatch.rowIndex ||\n      prevMatch.columnId !== nextMatch.columnId\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n});\n\nfunction DataGridSearchImpl({\n  searchMatches,\n  matchIndex,\n  searchOpen,\n  onSearchOpenChange,\n  searchQuery,\n  onSearchQueryChange,\n  onSearch,\n  onNavigateToNextMatch,\n  onNavigateToPrevMatch,\n}: DataGridSearchProps) {\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  React.useEffect(() => {\n    if (searchOpen) {\n      requestAnimationFrame(() => {\n        inputRef.current?.focus();\n      });\n    }\n  }, [searchOpen]);\n\n  React.useEffect(() => {\n    if (!searchOpen) return;\n\n    function onEscape(event: KeyboardEvent) {\n      if (event.key === \"Escape\") {\n        event.preventDefault();\n        onSearchOpenChange(false);\n      }\n    }\n\n    document.addEventListener(\"keydown\", onEscape);\n    return () => document.removeEventListener(\"keydown\", onEscape);\n  }, [searchOpen, onSearchOpenChange]);\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      event.stopPropagation();\n\n      if (event.key === \"Enter\") {\n        event.preventDefault();\n        if (event.shiftKey) {\n          onNavigateToPrevMatch();\n        } else {\n          onNavigateToNextMatch();\n        }\n      }\n    },\n    [onNavigateToNextMatch, onNavigateToPrevMatch],\n  );\n\n  const debouncedSearch = useDebouncedCallback((query: string) => {\n    onSearch(query);\n  }, 150);\n\n  const onChange = React.useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      const value = event.target.value;\n      onSearchQueryChange(value);\n      debouncedSearch(value);\n    },\n    [onSearchQueryChange, debouncedSearch],\n  );\n\n  const onTriggerPointerDown = React.useCallback(\n    (event: React.PointerEvent<HTMLButtonElement>) => {\n      // prevent implicit pointer capture\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) return;\n      if (target.hasPointerCapture(event.pointerId)) {\n        target.releasePointerCapture(event.pointerId);\n      }\n\n      // Only prevent default if we're not clicking on the input\n      // This allows text selection in the input while still preventing focus stealing elsewhere\n      if (\n        event.button === 0 &&\n        event.ctrlKey === false &&\n        event.pointerType === \"mouse\" &&\n        !(event.target instanceof HTMLInputElement)\n      ) {\n        event.preventDefault();\n      }\n    },\n    [],\n  );\n\n  const onPrevMatchPointerDown = React.useCallback(\n    (event: React.PointerEvent<HTMLButtonElement>) =>\n      onTriggerPointerDown(event),\n    [onTriggerPointerDown],\n  );\n\n  const onNextMatchPointerDown = React.useCallback(\n    (event: React.PointerEvent<HTMLButtonElement>) =>\n      onTriggerPointerDown(event),\n    [onTriggerPointerDown],\n  );\n\n  const onClose = React.useCallback(() => {\n    onSearchOpenChange(false);\n  }, [onSearchOpenChange]);\n\n  if (!searchOpen) return null;\n\n  return (\n    <div\n      role=\"search\"\n      data-slot=\"grid-search\"\n      className=\"fade-in-0 slide-in-from-top-2 absolute top-4 right-4 z-50 flex animate-in flex-col gap-2 rounded-lg border bg-background p-2 shadow-lg\"\n    >\n      <div className=\"flex items-center gap-2\">\n        <Input\n          autoComplete=\"off\"\n          autoCorrect=\"off\"\n          autoCapitalize=\"off\"\n          spellCheck={false}\n          placeholder=\"Find in table...\"\n          className=\"h-8 w-64\"\n          ref={inputRef}\n          value={searchQuery}\n          onChange={onChange}\n          onKeyDown={onKeyDown}\n        />\n        <div className=\"flex items-center gap-1\">\n          <Button\n            aria-label=\"Previous match\"\n            variant=\"ghost\"\n            size=\"icon\"\n            className=\"size-7\"\n            onClick={onNavigateToPrevMatch}\n            onPointerDown={onPrevMatchPointerDown}\n            disabled={searchMatches.length === 0}\n          >\n            <ChevronUp />\n          </Button>\n          <Button\n            aria-label=\"Next match\"\n            variant=\"ghost\"\n            size=\"icon\"\n            className=\"size-7\"\n            onClick={onNavigateToNextMatch}\n            onPointerDown={onNextMatchPointerDown}\n            disabled={searchMatches.length === 0}\n          >\n            <ChevronDown />\n          </Button>\n          <Button\n            aria-label=\"Close search\"\n            variant=\"ghost\"\n            size=\"icon\"\n            className=\"size-7\"\n            onClick={onClose}\n          >\n            <X />\n          </Button>\n        </div>\n      </div>\n      <div className=\"flex items-center gap-1 whitespace-nowrap text-muted-foreground text-xs\">\n        {searchMatches.length > 0 ? (\n          <span>\n            {matchIndex + 1} of {searchMatches.length}\n          </span>\n        ) : searchQuery ? (\n          <span>No results</span>\n        ) : (\n          <span>Type to search</span>\n        )}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-search.tsx"
    },
    {
      "path": "src/hooks/use-callback-ref.ts",
      "content": "import * as React from \"react\";\n\n/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/use-callback-ref/src/useCallbackRef.tsx\n */\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: never[]) => unknown>(\n  callback: T | undefined,\n): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(\n    () => ((...args) => callbackRef.current?.(...args)) as T,\n    [],\n  );\n}\n\nexport { useCallbackRef };\n",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/use-data-grid.tsx",
      "content": "\"use client\";\n\nimport {\n  type ColumnDef,\n  getCoreRowModel,\n  getSortedRowModel,\n  type RowSelectionState,\n  type SortingState,\n  type TableOptions,\n  type Updater,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { useVirtualizer, type Virtualizer } from \"@tanstack/react-virtual\";\nimport * as React from \"react\";\nimport { DataGridCell } from \"@/components/data-grid/data-grid-cell\";\nimport { getCellKey, getRowHeightValue, parseCellKey } from \"@/lib/data-grid\";\nimport type {\n  CellPosition,\n  ContextMenuState,\n  NavigationDirection,\n  RowHeightValue,\n  SearchState,\n  SelectionState,\n  UpdateCell,\n} from \"@/types/data-grid\";\n\nconst DEFAULT_ROW_HEIGHT = \"short\";\nconst OVERSCAN = 3;\nconst VIEWPORT_OFFSET = 1;\nconst MIN_COLUMN_SIZE = 60;\nconst MAX_COLUMN_SIZE = 800;\nconst SEARCH_SHORTCUT_KEY = \"f\";\nconst NON_NAVIGABLE_COLUMN_IDS = [\"select\", \"actions\"];\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\nfunction useLazyRef<T>(fn: () => T): React.RefObject<T> {\n  const ref = React.useRef<T | null>(null);\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n  return ref as React.RefObject<T>;\n}\n\nfunction useAsRef<T>(data: T) {\n  const ref = React.useRef<T>(data);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = data;\n  });\n\n  return ref;\n}\n\ninterface DataGridState {\n  sorting: SortingState;\n  rowHeight: RowHeightValue;\n  rowSelection: RowSelectionState;\n  selectionState: SelectionState;\n  focusedCell: CellPosition | null;\n  editingCell: CellPosition | null;\n  contextMenu: ContextMenuState;\n  searchQuery: string;\n  searchMatches: CellPosition[];\n  matchIndex: number;\n  searchOpen: boolean;\n  lastClickedRowIndex: number | null;\n  isScrolling: boolean;\n}\n\ninterface DataGridStore {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => DataGridState;\n  setState: <K extends keyof DataGridState>(\n    key: K,\n    value: DataGridState[K],\n  ) => void;\n  notify: () => void;\n  batch: (fn: () => void) => void;\n}\n\nfunction useStore<T>(\n  store: DataGridStore,\n  selector: (state: DataGridState) => T,\n): T {\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface UseDataGridProps<TData>\n  extends Omit<TableOptions<TData>, \"pageCount\" | \"getCoreRowModel\"> {\n  onDataChange?: (data: TData[]) => void;\n  rowHeight?: RowHeightValue;\n  overscan?: number;\n  autoFocus?: boolean | Partial<CellPosition>;\n  enableColumnSelection?: boolean;\n  enableSearch?: boolean;\n}\n\nexport function useDataGrid<TData>({\n  columns,\n  data,\n  onDataChange,\n  rowHeight: rowHeightProp = DEFAULT_ROW_HEIGHT,\n  overscan = OVERSCAN,\n  initialState,\n  autoFocus = false,\n  enableColumnSelection = false,\n  enableSearch = false,\n  ...dataGridProps\n}: UseDataGridProps<TData>) {\n  const dataGridRef = React.useRef<HTMLDivElement>(null);\n  const tableRef = React.useRef<ReturnType<typeof useReactTable<TData>>>(null);\n  const rowVirtualizerRef =\n    React.useRef<Virtualizer<HTMLDivElement, Element>>(null);\n  const headerRef = React.useRef<HTMLDivElement>(null);\n  const rowMapRef = React.useRef<Map<number, HTMLDivElement>>(new Map());\n  const footerRef = React.useRef<HTMLDivElement>(null);\n\n  const dataGridPropsRef = useAsRef(dataGridProps);\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n\n  const stateRef = useLazyRef<DataGridState>(() => {\n    return {\n      sorting: initialState?.sorting ?? [],\n      rowHeight: rowHeightProp,\n      rowSelection: initialState?.rowSelection ?? {},\n      selectionState: {\n        selectedCells: new Set(),\n        selectionRange: null,\n        isSelecting: false,\n      },\n      focusedCell: null,\n      editingCell: null,\n      contextMenu: {\n        open: false,\n        x: 0,\n        y: 0,\n      },\n      searchQuery: \"\",\n      searchMatches: [],\n      matchIndex: -1,\n      searchOpen: false,\n      lastClickedRowIndex: null,\n      isScrolling: false,\n    };\n  });\n\n  const store = React.useMemo<DataGridStore>(() => {\n    let isBatching = false;\n    let pendingNotification = false;\n\n    return {\n      subscribe: (callback) => {\n        listenersRef.current.add(callback);\n        return () => listenersRef.current.delete(callback);\n      },\n      getState: () => stateRef.current,\n      setState: (key, value) => {\n        if (Object.is(stateRef.current[key], value)) return;\n        stateRef.current[key] = value;\n\n        if (isBatching) {\n          pendingNotification = true;\n        } else {\n          if (!pendingNotification) {\n            pendingNotification = true;\n            queueMicrotask(() => {\n              pendingNotification = false;\n              store.notify();\n            });\n          }\n        }\n      },\n      notify: () => {\n        for (const listener of listenersRef.current) {\n          listener();\n        }\n      },\n      batch: (fn) => {\n        if (isBatching) {\n          fn();\n          return;\n        }\n\n        isBatching = true;\n        const wasPending = pendingNotification;\n        pendingNotification = false;\n\n        try {\n          fn();\n        } finally {\n          isBatching = false;\n          if (pendingNotification || wasPending) {\n            pendingNotification = false;\n            store.notify();\n          }\n        }\n      },\n    };\n  }, [listenersRef, stateRef]);\n\n  const focusedCell = useStore(store, (state) => state.focusedCell);\n  const editingCell = useStore(store, (state) => state.editingCell);\n  const selectionState = useStore(store, (state) => state.selectionState);\n  const searchQuery = useStore(store, (state) => state.searchQuery);\n  const searchMatches = useStore(store, (state) => state.searchMatches);\n  const matchIndex = useStore(store, (state) => state.matchIndex);\n  const searchOpen = useStore(store, (state) => state.searchOpen);\n  const sorting = useStore(store, (state) => state.sorting);\n  const rowSelection = useStore(store, (state) => state.rowSelection);\n  const contextMenu = useStore(store, (state) => state.contextMenu);\n  const rowHeight = useStore(store, (state) => state.rowHeight);\n  const isScrolling = useStore(store, (state) => state.isScrolling);\n\n  const rowHeightValue = getRowHeightValue(rowHeight);\n\n  const columnIds = React.useMemo(() => {\n    return columns\n      .map((c) => {\n        if (c.id) return c.id;\n        if (\"accessorKey\" in c) return c.accessorKey as string;\n        return undefined;\n      })\n      .filter((id): id is string => Boolean(id));\n  }, [columns]);\n\n  const navigableColumnIds = React.useMemo(() => {\n    return columnIds.filter((c) => !NON_NAVIGABLE_COLUMN_IDS.includes(c));\n  }, [columnIds]);\n\n  const onDataUpdate = React.useCallback(\n    (updates: UpdateCell | Array<UpdateCell>) => {\n      const updateArray = Array.isArray(updates) ? updates : [updates];\n\n      if (updateArray.length === 0) return;\n\n      const currentTable = tableRef.current;\n      const rows = currentTable?.getRowModel().rows;\n\n      const rowUpdatesMap = new Map<\n        number,\n        Array<Omit<UpdateCell, \"rowIndex\">>\n      >();\n\n      for (const update of updateArray) {\n        if (!rows || !currentTable) {\n          const existingUpdates = rowUpdatesMap.get(update.rowIndex) ?? [];\n          existingUpdates.push({\n            columnId: update.columnId,\n            value: update.value,\n          });\n          rowUpdatesMap.set(update.rowIndex, existingUpdates);\n        } else {\n          const row = rows[update.rowIndex];\n          if (!row) continue;\n\n          const originalData = row.original;\n          const originalRowIndex = data.indexOf(originalData);\n          if (originalRowIndex === -1) continue;\n\n          const existingUpdates = rowUpdatesMap.get(originalRowIndex) ?? [];\n          existingUpdates.push({\n            columnId: update.columnId,\n            value: update.value,\n          });\n          rowUpdatesMap.set(originalRowIndex, existingUpdates);\n        }\n      }\n\n      const newData = data.map((row, index) => {\n        const updates = rowUpdatesMap.get(index);\n        if (!updates) return row;\n\n        const updatedRow = { ...row } as Record<string, unknown>;\n        for (const { columnId, value } of updates) {\n          updatedRow[columnId] = value;\n        }\n        return updatedRow as TData;\n      });\n\n      onDataChange?.(newData);\n    },\n    [data, onDataChange],\n  );\n\n  const getIsCellSelected = React.useCallback(\n    (rowIndex: number, columnId: string) => {\n      return selectionState.selectedCells.has(getCellKey(rowIndex, columnId));\n    },\n    [selectionState.selectedCells],\n  );\n\n  const clearSelection = React.useCallback(() => {\n    store.batch(() => {\n      store.setState(\"selectionState\", {\n        selectedCells: new Set(),\n        selectionRange: null,\n        isSelecting: false,\n      });\n      store.setState(\"rowSelection\", {});\n    });\n  }, [store]);\n\n  const selectAll = React.useCallback(() => {\n    const allCells = new Set<string>();\n    const currentTable = tableRef.current;\n    const rows = currentTable?.getRowModel().rows ?? [];\n    const rowCount = rows.length ?? data.length;\n\n    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n      for (const columnId of columnIds) {\n        allCells.add(getCellKey(rowIndex, columnId));\n      }\n    }\n\n    const firstColumnId = columnIds[0];\n    const lastColumnId = columnIds[columnIds.length - 1];\n\n    store.setState(\"selectionState\", {\n      selectedCells: allCells,\n      selectionRange:\n        columnIds.length > 0 && rowCount > 0 && firstColumnId && lastColumnId\n          ? {\n              start: { rowIndex: 0, columnId: firstColumnId },\n              end: { rowIndex: rowCount - 1, columnId: lastColumnId },\n            }\n          : null,\n      isSelecting: false,\n    });\n  }, [columnIds, data.length, store]);\n\n  const selectColumn = React.useCallback(\n    (columnId: string) => {\n      const currentTable = tableRef.current;\n      const rows = currentTable?.getRowModel().rows ?? [];\n      const rowCount = rows.length ?? data.length;\n\n      if (rowCount === 0) return;\n\n      const selectedCells = new Set<string>();\n\n      for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n        selectedCells.add(getCellKey(rowIndex, columnId));\n      }\n\n      store.setState(\"selectionState\", {\n        selectedCells,\n        selectionRange: {\n          start: { rowIndex: 0, columnId },\n          end: { rowIndex: rowCount - 1, columnId },\n        },\n        isSelecting: false,\n      });\n    },\n    [data.length, store],\n  );\n\n  const selectRange = React.useCallback(\n    (start: CellPosition, end: CellPosition, isSelecting = false) => {\n      const startColIndex = columnIds.indexOf(start.columnId);\n      const endColIndex = columnIds.indexOf(end.columnId);\n\n      const minRow = Math.min(start.rowIndex, end.rowIndex);\n      const maxRow = Math.max(start.rowIndex, end.rowIndex);\n      const minCol = Math.min(startColIndex, endColIndex);\n      const maxCol = Math.max(startColIndex, endColIndex);\n\n      const selectedCells = new Set<string>();\n\n      for (let rowIndex = minRow; rowIndex <= maxRow; rowIndex++) {\n        for (let colIndex = minCol; colIndex <= maxCol; colIndex++) {\n          const columnId = columnIds[colIndex];\n          if (columnId) {\n            selectedCells.add(getCellKey(rowIndex, columnId));\n          }\n        }\n      }\n\n      store.setState(\"selectionState\", {\n        selectedCells,\n        selectionRange: { start, end },\n        isSelecting,\n      });\n    },\n    [columnIds, store],\n  );\n\n  const focusCell = React.useCallback(\n    (rowIndex: number, columnId: string) => {\n      store.batch(() => {\n        store.setState(\"focusedCell\", { rowIndex, columnId });\n        store.setState(\"editingCell\", null);\n      });\n\n      const currentState = store.getState();\n\n      if (currentState.searchOpen) return;\n\n      if (\n        dataGridRef.current &&\n        document.activeElement !== dataGridRef.current\n      ) {\n        dataGridRef.current.focus();\n      }\n    },\n    [store],\n  );\n\n  const navigateCell = React.useCallback(\n    (direction: NavigationDirection) => {\n      const currentState = store.getState();\n      if (!currentState.focusedCell) return;\n\n      const { rowIndex, columnId } = currentState.focusedCell;\n      const currentColIndex = navigableColumnIds.indexOf(columnId);\n      const rowVirtualizer = rowVirtualizerRef.current;\n      const currentTable = tableRef.current;\n      const rows = currentTable?.getRowModel().rows ?? [];\n      const rowCount = rows.length ?? data.length;\n\n      let newRowIndex = rowIndex;\n      let newColumnId = columnId;\n\n      switch (direction) {\n        case \"up\":\n          newRowIndex = Math.max(0, rowIndex - 1);\n          break;\n        case \"down\":\n          newRowIndex = Math.min(rowCount - 1, rowIndex + 1);\n          break;\n        case \"left\":\n          if (currentColIndex > 0) {\n            const prevColumnId = navigableColumnIds[currentColIndex - 1];\n            if (prevColumnId) newColumnId = prevColumnId;\n          }\n          break;\n        case \"right\":\n          if (currentColIndex < navigableColumnIds.length - 1) {\n            const nextColumnId = navigableColumnIds[currentColIndex + 1];\n            if (nextColumnId) newColumnId = nextColumnId;\n          }\n          break;\n        case \"home\":\n          if (navigableColumnIds.length > 0) {\n            newColumnId = navigableColumnIds[0] ?? columnId;\n          }\n          break;\n        case \"end\":\n          if (navigableColumnIds.length > 0) {\n            newColumnId =\n              navigableColumnIds[navigableColumnIds.length - 1] ?? columnId;\n          }\n          break;\n        case \"ctrl+home\":\n          newRowIndex = 0;\n          if (navigableColumnIds.length > 0) {\n            newColumnId = navigableColumnIds[0] ?? columnId;\n          }\n          break;\n        case \"ctrl+end\":\n          newRowIndex = Math.max(0, rowCount - 1);\n          if (navigableColumnIds.length > 0) {\n            newColumnId =\n              navigableColumnIds[navigableColumnIds.length - 1] ?? columnId;\n          }\n          break;\n        case \"pageup\":\n          if (rowVirtualizer) {\n            const visibleRange = rowVirtualizer.getVirtualItems();\n            const pageSize = visibleRange.length ?? 10;\n            newRowIndex = Math.max(0, rowIndex - pageSize);\n          } else {\n            newRowIndex = Math.max(0, rowIndex - 10);\n          }\n          break;\n        case \"pagedown\":\n          if (rowVirtualizer) {\n            const visibleRange = rowVirtualizer.getVirtualItems();\n            const pageSize = visibleRange.length ?? 10;\n            newRowIndex = Math.min(rowCount - 1, rowIndex + pageSize);\n          } else {\n            newRowIndex = Math.min(rowCount - 1, rowIndex + 10);\n          }\n          break;\n      }\n\n      if (newRowIndex !== rowIndex || newColumnId !== columnId) {\n        const rowDiff = newRowIndex - rowIndex;\n\n        // For single-row vertical navigation (up/down arrows)\n        if (\n          Math.abs(rowDiff) === 1 &&\n          (direction === \"up\" || direction === \"down\")\n        ) {\n          const container = dataGridRef.current;\n          const currentRow = rowMapRef.current.get(rowIndex);\n          const targetRow = rowMapRef.current.get(newRowIndex);\n\n          if (!container || !currentRow) {\n            // Fallback to simple focus if we can't find elements\n            focusCell(newRowIndex, newColumnId);\n            return;\n          }\n\n          // Check viewport boundaries\n          const containerRect = container.getBoundingClientRect();\n          const headerHeight =\n            headerRef.current?.getBoundingClientRect().height ?? 0;\n          const footerHeight =\n            footerRef.current?.getBoundingClientRect().height ?? 0;\n\n          const viewportTop =\n            containerRect.top + headerHeight + VIEWPORT_OFFSET;\n          const viewportBottom =\n            containerRect.bottom - footerHeight - VIEWPORT_OFFSET;\n\n          // If target row already exists, check if it's visible\n          if (targetRow) {\n            const rowRect = targetRow.getBoundingClientRect();\n            const isFullyVisible =\n              rowRect.top >= viewportTop && rowRect.bottom <= viewportBottom;\n\n            if (isFullyVisible) {\n              // Row is fully visible, just focus it\n              focusCell(newRowIndex, newColumnId);\n              return;\n            }\n\n            // Row exists but not fully visible, scroll it into view\n            focusCell(newRowIndex, newColumnId);\n\n            if (direction === \"down\") {\n              // Scroll just enough to show the row at the bottom\n              const scrollNeeded = rowRect.bottom - viewportBottom;\n              container.scrollTop += scrollNeeded;\n            } else {\n              // Scroll just enough to show the row at the top\n              const scrollNeeded = viewportTop - rowRect.top;\n              container.scrollTop -= scrollNeeded;\n            }\n            return;\n          }\n\n          // Target row is not rendered yet\n          // Focus immediately so the ring appears as the row is revealed\n          focusCell(newRowIndex, newColumnId);\n\n          // Scroll by exactly one row height to reveal it smoothly\n          if (direction === \"down\") {\n            container.scrollTop += rowHeightValue;\n          } else {\n            // For arrow up, ensure we don't go below 0\n            const currentScrollTop = container.scrollTop;\n            const targetScrollTop = Math.max(\n              0,\n              currentScrollTop - rowHeightValue,\n            );\n            container.scrollTop = targetScrollTop;\n          }\n          return;\n        }\n\n        // For larger jumps (page up/down, ctrl+home/end, etc.)\n        if (rowVirtualizer && Math.abs(rowDiff) > 1) {\n          const align =\n            direction === \"pageup\" || direction === \"ctrl+home\"\n              ? \"start\"\n              : direction === \"pagedown\" || direction === \"ctrl+end\"\n                ? \"end\"\n                : \"center\";\n          rowVirtualizer.scrollToIndex(newRowIndex, { align });\n          requestAnimationFrame(() => {\n            focusCell(newRowIndex, newColumnId);\n          });\n          return;\n        }\n\n        // For horizontal navigation or when row is already visible\n        focusCell(newRowIndex, newColumnId);\n      }\n    },\n    [store, navigableColumnIds, focusCell, data.length, rowHeightValue],\n  );\n\n  const onCellEditingStart = React.useCallback(\n    (rowIndex: number, columnId: string) => {\n      store.batch(() => {\n        store.setState(\"focusedCell\", { rowIndex, columnId });\n        store.setState(\"editingCell\", { rowIndex, columnId });\n      });\n    },\n    [store],\n  );\n\n  const onCellEditingStop = React.useCallback(\n    (opts?: { moveToNextRow?: boolean; direction?: NavigationDirection }) => {\n      const currentState = store.getState();\n      const currentEditing = currentState.editingCell;\n\n      store.setState(\"editingCell\", null);\n\n      if (opts?.moveToNextRow && currentEditing) {\n        const { rowIndex, columnId } = currentEditing;\n        const currentTable = tableRef.current;\n        const rows = currentTable?.getRowModel().rows ?? [];\n        const rowCount = rows.length ?? data.length;\n\n        const nextRowIndex = rowIndex + 1;\n        if (nextRowIndex < rowCount) {\n          requestAnimationFrame(() => {\n            focusCell(nextRowIndex, columnId);\n          });\n        }\n      } else if (opts?.direction && currentEditing) {\n        // Focus the current editing cell first, then navigate\n        const { rowIndex, columnId } = currentEditing;\n        focusCell(rowIndex, columnId);\n        requestAnimationFrame(() => {\n          navigateCell(opts.direction ?? \"right\");\n        });\n      }\n    },\n    [store, data.length, focusCell, navigateCell],\n  );\n\n  const onSearchOpenChange = React.useCallback(\n    (open: boolean) => {\n      if (open) {\n        store.setState(\"searchOpen\", true);\n        return;\n      }\n\n      const currentState = store.getState();\n      const currentMatch =\n        currentState.matchIndex >= 0 &&\n        currentState.searchMatches[currentState.matchIndex];\n\n      store.batch(() => {\n        store.setState(\"searchOpen\", false);\n        store.setState(\"searchQuery\", \"\");\n        store.setState(\"searchMatches\", []);\n        store.setState(\"matchIndex\", -1);\n\n        if (currentMatch) {\n          store.setState(\"focusedCell\", {\n            rowIndex: currentMatch.rowIndex,\n            columnId: currentMatch.columnId,\n          });\n        }\n      });\n\n      if (\n        dataGridRef.current &&\n        document.activeElement !== dataGridRef.current\n      ) {\n        dataGridRef.current.focus();\n      }\n    },\n    [store],\n  );\n\n  const onSearch = React.useCallback(\n    (query: string) => {\n      if (!query.trim()) {\n        store.batch(() => {\n          store.setState(\"searchMatches\", []);\n          store.setState(\"matchIndex\", -1);\n        });\n        return;\n      }\n\n      const matches: CellPosition[] = [];\n      const currentTable = tableRef.current;\n      const rows = currentTable?.getRowModel().rows ?? [];\n\n      const lowerQuery = query.toLowerCase();\n\n      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n        const row = rows[rowIndex];\n        if (!row) continue;\n\n        for (const columnId of columnIds) {\n          const cell = row\n            .getVisibleCells()\n            .find((c) => c.column.id === columnId);\n          if (!cell) continue;\n\n          const value = cell.getValue();\n          const stringValue = String(value ?? \"\").toLowerCase();\n\n          if (stringValue.includes(lowerQuery)) {\n            matches.push({ rowIndex, columnId });\n          }\n        }\n      }\n\n      store.batch(() => {\n        store.setState(\"searchMatches\", matches);\n        store.setState(\"matchIndex\", matches.length > 0 ? 0 : -1);\n      });\n\n      // Scroll to first match but don't focus it (to keep focus in search input)\n      if (matches.length > 0 && matches[0]) {\n        const firstMatch = matches[0];\n        rowVirtualizerRef.current?.scrollToIndex(firstMatch.rowIndex, {\n          align: \"center\",\n        });\n      }\n    },\n    [columnIds, store],\n  );\n\n  const onSearchQueryChange = React.useCallback(\n    (query: string) => store.setState(\"searchQuery\", query),\n    [store],\n  );\n\n  const onNavigateToPrevMatch = React.useCallback(() => {\n    const currentState = store.getState();\n    if (currentState.searchMatches.length === 0) return;\n\n    const prevIndex =\n      currentState.matchIndex - 1 < 0\n        ? currentState.searchMatches.length - 1\n        : currentState.matchIndex - 1;\n    const match = currentState.searchMatches[prevIndex];\n\n    if (match) {\n      rowVirtualizerRef.current?.scrollToIndex(match.rowIndex, {\n        align: \"center\",\n      });\n\n      requestAnimationFrame(() => {\n        store.setState(\"matchIndex\", prevIndex);\n        requestAnimationFrame(() => {\n          focusCell(match.rowIndex, match.columnId);\n        });\n      });\n    }\n  }, [store, focusCell]);\n\n  const onNavigateToNextMatch = React.useCallback(() => {\n    const currentState = store.getState();\n    if (currentState.searchMatches.length === 0) return;\n\n    const nextIndex =\n      (currentState.matchIndex + 1) % currentState.searchMatches.length;\n    const match = currentState.searchMatches[nextIndex];\n\n    if (match) {\n      rowVirtualizerRef.current?.scrollToIndex(match.rowIndex, {\n        align: \"center\",\n      });\n\n      requestAnimationFrame(() => {\n        store.setState(\"matchIndex\", nextIndex);\n        requestAnimationFrame(() => {\n          focusCell(match.rowIndex, match.columnId);\n        });\n      });\n    }\n  }, [store, focusCell]);\n\n  const getIsSearchMatch = React.useCallback(\n    (rowIndex: number, columnId: string) => {\n      return searchMatches.some(\n        (match) => match.rowIndex === rowIndex && match.columnId === columnId,\n      );\n    },\n    [searchMatches],\n  );\n\n  const getIsActiveSearchMatch = React.useCallback(\n    (rowIndex: number, columnId: string) => {\n      if (matchIndex < 0) return false;\n      const currentMatch = searchMatches[matchIndex];\n      return (\n        currentMatch?.rowIndex === rowIndex &&\n        currentMatch?.columnId === columnId\n      );\n    },\n    [searchMatches, matchIndex],\n  );\n\n  const blurCell = React.useCallback(() => {\n    const currentState = store.getState();\n    if (\n      currentState.editingCell &&\n      document.activeElement instanceof HTMLElement\n    ) {\n      document.activeElement.blur();\n    }\n\n    store.batch(() => {\n      store.setState(\"focusedCell\", null);\n      store.setState(\"editingCell\", null);\n    });\n  }, [store]);\n\n  const onCellClick = React.useCallback(\n    (rowIndex: number, columnId: string, event?: React.MouseEvent) => {\n      // Ignore right-click (button 2) - let onCellContextMenu handle it\n      if (event?.button === 2) {\n        return;\n      }\n\n      const currentState = store.getState();\n      const currentFocused = currentState.focusedCell;\n\n      if (event) {\n        if (event.ctrlKey || event.metaKey) {\n          event.preventDefault();\n          const cellKey = getCellKey(rowIndex, columnId);\n          const newSelectedCells = new Set(\n            currentState.selectionState.selectedCells,\n          );\n\n          if (newSelectedCells.has(cellKey)) {\n            newSelectedCells.delete(cellKey);\n          } else {\n            newSelectedCells.add(cellKey);\n          }\n\n          store.setState(\"selectionState\", {\n            selectedCells: newSelectedCells,\n            selectionRange: null,\n            isSelecting: false,\n          });\n          focusCell(rowIndex, columnId);\n          return;\n        }\n\n        if (event.shiftKey && currentState.focusedCell) {\n          event.preventDefault();\n          selectRange(currentState.focusedCell, { rowIndex, columnId });\n          return;\n        }\n      }\n\n      // Clear selection if there are selected cells or rows\n      const hasSelectedCells =\n        currentState.selectionState.selectedCells.size > 0;\n      const hasSelectedRows = Object.keys(currentState.rowSelection).length > 0;\n\n      if (hasSelectedCells && !currentState.selectionState.isSelecting) {\n        // If there's a cell selection but we're not actively selecting (drag just finished),\n        // don't clear it - keep the selection\n        // Only clear if clicking elsewhere\n        const cellKey = getCellKey(rowIndex, columnId);\n        const isClickingSelectedCell =\n          currentState.selectionState.selectedCells.has(cellKey);\n\n        if (!isClickingSelectedCell) {\n          clearSelection();\n        } else {\n          // Clicking on an already selected cell - just focus it\n          focusCell(rowIndex, columnId);\n          return;\n        }\n      } else if (hasSelectedRows && columnId !== \"select\") {\n        // If there are selected rows but we're clicking on a non-checkbox cell, clear selections\n        clearSelection();\n      }\n\n      if (\n        currentFocused?.rowIndex === rowIndex &&\n        currentFocused?.columnId === columnId\n      ) {\n        onCellEditingStart(rowIndex, columnId);\n      } else {\n        focusCell(rowIndex, columnId);\n      }\n    },\n    [store, focusCell, onCellEditingStart, selectRange, clearSelection],\n  );\n\n  const onCellDoubleClick = React.useCallback(\n    (rowIndex: number, columnId: string, event?: React.MouseEvent) => {\n      if (event?.defaultPrevented) return;\n\n      onCellEditingStart(rowIndex, columnId);\n    },\n    [onCellEditingStart],\n  );\n\n  const onCellMouseDown = React.useCallback(\n    (rowIndex: number, columnId: string, event: React.MouseEvent) => {\n      // Ignore right-click (button 2) - let onCellContextMenu handle it\n      if (event.button === 2) {\n        return;\n      }\n\n      event.preventDefault();\n\n      // Only start drag selection if no modifier keys are pressed\n      // Clear any existing selection and prepare for potential drag\n      if (!event.ctrlKey && !event.metaKey && !event.shiftKey) {\n        store.batch(() => {\n          store.setState(\"selectionState\", {\n            selectedCells: new Set(),\n            selectionRange: {\n              start: { rowIndex, columnId },\n              end: { rowIndex, columnId },\n            },\n            isSelecting: true,\n          });\n          store.setState(\"rowSelection\", {});\n        });\n      }\n    },\n    [store],\n  );\n\n  const onCellMouseEnter = React.useCallback(\n    (rowIndex: number, columnId: string, _event: React.MouseEvent) => {\n      const currentState = store.getState();\n      if (\n        currentState.selectionState.isSelecting &&\n        currentState.selectionState.selectionRange\n      ) {\n        const start = currentState.selectionState.selectionRange.start;\n        const end = { rowIndex, columnId };\n\n        if (\n          currentState.focusedCell?.rowIndex !== start.rowIndex ||\n          currentState.focusedCell?.columnId !== start.columnId\n        ) {\n          focusCell(start.rowIndex, start.columnId);\n        }\n\n        selectRange(start, end, true);\n      }\n    },\n    [store, selectRange, focusCell],\n  );\n\n  const onCellMouseUp = React.useCallback(() => {\n    const currentState = store.getState();\n    store.setState(\"selectionState\", {\n      ...currentState.selectionState,\n      isSelecting: false,\n    });\n  }, [store]);\n\n  const onCellContextMenu = React.useCallback(\n    (rowIndex: number, columnId: string, event: React.MouseEvent) => {\n      event.preventDefault();\n      event.stopPropagation();\n\n      const currentState = store.getState();\n      const cellKey = getCellKey(rowIndex, columnId);\n      const isTargetCellSelected =\n        currentState.selectionState.selectedCells.has(cellKey);\n\n      // If right-clicking on a non-selected cell, select only that cell\n      if (!isTargetCellSelected) {\n        store.batch(() => {\n          store.setState(\"selectionState\", {\n            selectedCells: new Set([cellKey]),\n            selectionRange: {\n              start: { rowIndex, columnId },\n              end: { rowIndex, columnId },\n            },\n            isSelecting: false,\n          });\n          store.setState(\"focusedCell\", { rowIndex, columnId });\n        });\n      }\n\n      // Open context menu at cursor position\n      store.setState(\"contextMenu\", {\n        open: true,\n        x: event.clientX,\n        y: event.clientY,\n      });\n    },\n    [store],\n  );\n\n  const onContextMenuOpenChange = React.useCallback(\n    (open: boolean) => {\n      if (!open) {\n        const currentMenu = store.getState().contextMenu;\n        store.setState(\"contextMenu\", {\n          open: false,\n          x: currentMenu.x,\n          y: currentMenu.y,\n        });\n      }\n    },\n    [store],\n  );\n\n  const onDataGridKeyDown = React.useCallback(\n    (event: KeyboardEvent) => {\n      const currentState = store.getState();\n      const { key, ctrlKey, metaKey, shiftKey } = event;\n      const isCtrlPressed = ctrlKey || metaKey;\n\n      // Handle Cmd+F / Ctrl+F to open search (highest priority, works even when editing)\n      if (enableSearch && isCtrlPressed && key === SEARCH_SHORTCUT_KEY) {\n        event.preventDefault();\n        onSearchOpenChange(true);\n        return;\n      }\n\n      // Handle search navigation when search is open\n      if (\n        enableSearch &&\n        currentState.searchOpen &&\n        !currentState.editingCell\n      ) {\n        if (key === \"Enter\") {\n          event.preventDefault();\n          if (shiftKey) {\n            onNavigateToPrevMatch();\n          } else {\n            onNavigateToNextMatch();\n          }\n          return;\n        }\n        if (key === \"Escape\") {\n          event.preventDefault();\n          onSearchOpenChange(false);\n          return;\n        }\n        // When search is open, don't let data grid handle any other keys\n        // (they should only affect the search input)\n        return;\n      }\n\n      if (currentState.editingCell) return;\n\n      if (!currentState.focusedCell) return;\n\n      let direction: NavigationDirection | null = null;\n\n      if (isCtrlPressed && key === \"a\") {\n        event.preventDefault();\n        selectAll();\n        return;\n      }\n\n      if (key === \"Delete\" || key === \"Backspace\") {\n        if (currentState.selectionState.selectedCells.size > 0) {\n          event.preventDefault();\n          const updates: Array<{\n            rowIndex: number;\n            columnId: string;\n            value: unknown;\n          }> = [];\n\n          currentState.selectionState.selectedCells.forEach((cellKey) => {\n            const { rowIndex, columnId } = parseCellKey(cellKey);\n            updates.push({ rowIndex, columnId, value: \"\" });\n          });\n\n          onDataUpdate(updates);\n          clearSelection();\n        }\n        return;\n      }\n\n      switch (key) {\n        case \"ArrowUp\":\n          direction = \"up\";\n          break;\n        case \"ArrowDown\":\n          direction = \"down\";\n          break;\n        case \"ArrowLeft\":\n          direction = \"left\";\n          break;\n        case \"ArrowRight\":\n          direction = \"right\";\n          break;\n        case \"Home\":\n          direction = isCtrlPressed ? \"ctrl+home\" : \"home\";\n          break;\n        case \"End\":\n          direction = isCtrlPressed ? \"ctrl+end\" : \"end\";\n          break;\n        case \"PageUp\":\n          direction = \"pageup\";\n          break;\n        case \"PageDown\":\n          direction = \"pagedown\";\n          break;\n        case \"Escape\":\n          event.preventDefault();\n          if (\n            currentState.selectionState.selectedCells.size > 0 ||\n            Object.keys(currentState.rowSelection).length > 0\n          ) {\n            clearSelection();\n          } else {\n            blurCell();\n          }\n          return;\n        case \"Tab\":\n          event.preventDefault();\n          direction = event.shiftKey ? \"left\" : \"right\";\n          break;\n      }\n\n      if (direction) {\n        event.preventDefault();\n\n        // Tab navigation should not trigger selection, even with Shift\n        if (shiftKey && key !== \"Tab\" && currentState.focusedCell) {\n          const currentColIndex = navigableColumnIds.indexOf(\n            currentState.focusedCell.columnId,\n          );\n          let newRowIndex = currentState.focusedCell.rowIndex;\n          let newColumnId = currentState.focusedCell.columnId;\n\n          switch (direction) {\n            case \"up\":\n              newRowIndex = Math.max(0, currentState.focusedCell.rowIndex - 1);\n              break;\n            case \"down\":\n              newRowIndex = Math.min(\n                (tableRef.current?.getRowModel().rows.length || data.length) -\n                  1,\n                currentState.focusedCell.rowIndex + 1,\n              );\n              break;\n            case \"left\":\n              if (currentColIndex > 0) {\n                const prevColumnId = navigableColumnIds[currentColIndex - 1];\n                if (prevColumnId) newColumnId = prevColumnId;\n              }\n              break;\n            case \"right\":\n              if (currentColIndex < navigableColumnIds.length - 1) {\n                const nextColumnId = navigableColumnIds[currentColIndex + 1];\n                if (nextColumnId) newColumnId = nextColumnId;\n              }\n              break;\n          }\n\n          const selectionStart =\n            currentState.selectionState.selectionRange?.start ||\n            currentState.focusedCell;\n          selectRange(selectionStart, {\n            rowIndex: newRowIndex,\n            columnId: newColumnId,\n          });\n          focusCell(newRowIndex, newColumnId);\n        } else {\n          if (currentState.selectionState.selectedCells.size > 0) {\n            clearSelection();\n          }\n          navigateCell(direction);\n        }\n      }\n    },\n    [\n      store,\n      blurCell,\n      navigateCell,\n      selectAll,\n      onDataUpdate,\n      clearSelection,\n      navigableColumnIds,\n      data.length,\n      selectRange,\n      focusCell,\n      onSearchOpenChange,\n      onNavigateToNextMatch,\n      onNavigateToPrevMatch,\n      enableSearch,\n    ],\n  );\n\n  const onSortingChange = React.useCallback(\n    (updater: Updater<SortingState>) => {\n      const currentState = store.getState();\n      const newSorting =\n        typeof updater === \"function\" ? updater(currentState.sorting) : updater;\n      store.setState(\"sorting\", newSorting);\n    },\n    [store],\n  );\n\n  const onRowSelectionChange = React.useCallback(\n    (updater: Updater<RowSelectionState>) => {\n      const currentState = store.getState();\n      const newRowSelection =\n        typeof updater === \"function\"\n          ? updater(currentState.rowSelection)\n          : updater;\n\n      const selectedRows = Object.keys(newRowSelection).filter(\n        (key) => newRowSelection[key],\n      );\n\n      const selectedCells = new Set<string>();\n      const rows = tableRef.current?.getRowModel().rows ?? [];\n\n      for (const rowId of selectedRows) {\n        const rowIndex = rows.findIndex((r) => r.id === rowId);\n        if (rowIndex === -1) continue;\n\n        for (const columnId of columnIds) {\n          selectedCells.add(getCellKey(rowIndex, columnId));\n        }\n      }\n\n      store.batch(() => {\n        store.setState(\"rowSelection\", newRowSelection);\n        store.setState(\"selectionState\", {\n          selectedCells,\n          selectionRange: null,\n          isSelecting: false,\n        });\n        store.setState(\"focusedCell\", null);\n        store.setState(\"editingCell\", null);\n      });\n    },\n    [store, columnIds],\n  );\n\n  const onRowSelect = React.useCallback(\n    (rowIndex: number, selected: boolean, shiftKey: boolean) => {\n      const currentState = store.getState();\n      const rows = tableRef.current?.getRowModel().rows ?? [];\n      const currentRow = rows[rowIndex];\n      if (!currentRow) return;\n\n      if (shiftKey && currentState.lastClickedRowIndex !== null) {\n        const startIndex = Math.min(currentState.lastClickedRowIndex, rowIndex);\n        const endIndex = Math.max(currentState.lastClickedRowIndex, rowIndex);\n\n        const newRowSelection: RowSelectionState = {\n          ...currentState.rowSelection,\n        };\n\n        for (let i = startIndex; i <= endIndex; i++) {\n          const row = rows[i];\n          if (row) {\n            newRowSelection[row.id] = selected;\n          }\n        }\n\n        onRowSelectionChange(newRowSelection);\n      } else {\n        onRowSelectionChange({\n          ...currentState.rowSelection,\n          [currentRow.id]: selected,\n        });\n      }\n\n      store.setState(\"lastClickedRowIndex\", rowIndex);\n    },\n    [store, onRowSelectionChange],\n  );\n\n  const onRowHeightChange = React.useCallback(\n    (updater: Updater<RowHeightValue>) => {\n      const currentState = store.getState();\n      const newRowHeight =\n        typeof updater === \"function\"\n          ? updater(currentState.rowHeight)\n          : updater;\n      store.setState(\"rowHeight\", newRowHeight);\n    },\n    [store],\n  );\n\n  const onColumnClick = React.useCallback(\n    (columnId: string) => {\n      if (!enableColumnSelection) {\n        clearSelection();\n        return;\n      }\n\n      selectColumn(columnId);\n    },\n    [enableColumnSelection, selectColumn, clearSelection],\n  );\n\n  const defaultColumn: Partial<ColumnDef<TData>> = React.useMemo(\n    () => ({\n      cell: DataGridCell,\n      minSize: MIN_COLUMN_SIZE,\n      maxSize: MAX_COLUMN_SIZE,\n    }),\n    [],\n  );\n\n  const tableOptions = React.useMemo<TableOptions<TData>>(\n    () => ({\n      ...dataGridPropsRef.current,\n      data,\n      columns,\n      defaultColumn,\n      initialState,\n      state: {\n        ...dataGridPropsRef.current.state,\n        sorting,\n        rowSelection,\n      },\n      onRowSelectionChange,\n      onSortingChange,\n      columnResizeMode: \"onChange\",\n      getCoreRowModel: getCoreRowModel(),\n      getSortedRowModel: getSortedRowModel(),\n      meta: {\n        ...dataGridPropsRef.current.meta,\n        dataGridRef,\n        focusedCell,\n        editingCell,\n        selectionState,\n        searchOpen,\n        isScrolling,\n        getIsCellSelected,\n        getIsSearchMatch,\n        getIsActiveSearchMatch,\n        onDataUpdate,\n        onColumnClick,\n        onCellClick,\n        onCellDoubleClick,\n        onCellMouseDown,\n        onCellMouseEnter,\n        onCellMouseUp,\n        onCellContextMenu,\n        onCellEditingStart,\n        onCellEditingStop,\n        contextMenu,\n        onContextMenuOpenChange,\n        rowHeight,\n        onRowHeightChange,\n        onRowSelect,\n      },\n    }),\n    [\n      dataGridPropsRef,\n      data,\n      columns,\n      defaultColumn,\n      initialState,\n      sorting,\n      rowSelection,\n      onRowSelectionChange,\n      onSortingChange,\n      focusedCell,\n      editingCell,\n      selectionState,\n      searchOpen,\n      isScrolling,\n      getIsCellSelected,\n      getIsSearchMatch,\n      getIsActiveSearchMatch,\n      onDataUpdate,\n      onColumnClick,\n      onCellClick,\n      onCellDoubleClick,\n      onCellMouseDown,\n      onCellMouseEnter,\n      onCellMouseUp,\n      onCellContextMenu,\n      onCellEditingStart,\n      onCellEditingStop,\n      contextMenu,\n      onContextMenuOpenChange,\n      rowHeight,\n      onRowHeightChange,\n      onRowSelect,\n    ],\n  );\n\n  const table = useReactTable(tableOptions);\n\n  if (!tableRef.current) {\n    tableRef.current = table;\n  }\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we need to memoize the column size vars\n  const columnSizeVars = React.useMemo(() => {\n    const headers = table.getFlatHeaders();\n    const colSizes: { [key: string]: number } = {};\n    for (const header of headers) {\n      colSizes[`--header-${header.id}-size`] = header.getSize();\n      colSizes[`--col-${header.column.id}-size`] = header.column.getSize();\n    }\n    return colSizes;\n  }, [table.getState().columnSizingInfo, table.getState().columnSizing]);\n\n  const rowVirtualizer = useVirtualizer({\n    count: table.getRowModel().rows.length,\n    getScrollElement: () => dataGridRef.current,\n    estimateSize: () => rowHeightValue,\n    overscan,\n    measureElement:\n      typeof window !== \"undefined\" &&\n      navigator.userAgent.indexOf(\"Firefox\") === -1\n        ? (element) => element?.getBoundingClientRect().height\n        : undefined,\n    onChange: (instance) => {\n      // Sync virtualizer's isScrolling state to our store\n      const virtualizerIsScrolling = instance.isScrolling;\n      const currentIsScrolling = store.getState().isScrolling;\n\n      if (virtualizerIsScrolling !== currentIsScrolling) {\n        store.setState(\"isScrolling\", virtualizerIsScrolling);\n      }\n\n      // Batch DOM updates in a single animation frame\n      const virtualItems = instance.getVirtualItems();\n      if (virtualItems.length === 0) return;\n\n      requestAnimationFrame(() => {\n        for (let i = 0; i < virtualItems.length; i++) {\n          const virtualRow = virtualItems[i];\n          if (!virtualRow) continue;\n          const rowRef = rowMapRef.current.get(virtualRow.index);\n          if (rowRef) {\n            rowRef.style.transform = `translateY(${virtualRow.start}px)`;\n          }\n        }\n      });\n    },\n  });\n\n  if (!rowVirtualizerRef.current) {\n    rowVirtualizerRef.current = rowVirtualizer;\n  }\n\n  const scrollToRow = React.useCallback(\n    async (opts: Partial<CellPosition>) => {\n      const rowIndex = opts?.rowIndex ?? 0;\n      const columnId = opts?.columnId;\n\n      rowVirtualizer.scrollToIndex(rowIndex, {\n        align: \"center\",\n      });\n\n      const targetColumnId = columnId ?? navigableColumnIds[0];\n\n      if (!targetColumnId) return;\n\n      queueMicrotask(() => {\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            store.batch(() => {\n              store.setState(\"focusedCell\", {\n                rowIndex,\n                columnId: targetColumnId,\n              });\n              store.setState(\"editingCell\", null);\n            });\n          });\n        });\n      });\n    },\n    [rowVirtualizer, navigableColumnIds, store],\n  );\n\n  const searchState = React.useMemo<SearchState | undefined>(() => {\n    if (!enableSearch) return undefined;\n\n    return {\n      searchMatches,\n      matchIndex,\n      searchOpen,\n      onSearchOpenChange,\n      searchQuery,\n      onSearchQueryChange,\n      onSearch,\n      onNavigateToNextMatch,\n      onNavigateToPrevMatch,\n    };\n  }, [\n    enableSearch,\n    searchMatches,\n    matchIndex,\n    searchOpen,\n    onSearchOpenChange,\n    searchQuery,\n    onSearchQueryChange,\n    onSearch,\n    onNavigateToNextMatch,\n    onNavigateToPrevMatch,\n  ]);\n\n  React.useEffect(() => {\n    const dataGridElement = dataGridRef.current;\n    if (!dataGridElement) return;\n\n    dataGridElement.addEventListener(\"keydown\", onDataGridKeyDown);\n    return () => {\n      dataGridElement.removeEventListener(\"keydown\", onDataGridKeyDown);\n    };\n  }, [onDataGridKeyDown]);\n\n  React.useEffect(() => {\n    function onGlobalKeyDown(event: KeyboardEvent) {\n      const dataGridElement = dataGridRef.current;\n      if (!dataGridElement) return;\n\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) return;\n\n      const { key, ctrlKey, metaKey } = event;\n      const isCtrlPressed = ctrlKey || metaKey;\n\n      if (enableSearch && isCtrlPressed && key === SEARCH_SHORTCUT_KEY) {\n        const isInInput =\n          target.tagName === \"INPUT\" || target.tagName === \"TEXTAREA\";\n        const isInDataGrid = dataGridElement.contains(target);\n        const isInSearchInput = target.closest('[role=\"search\"]') !== null;\n\n        if (isInDataGrid || isInSearchInput || !isInInput) {\n          event.preventDefault();\n          event.stopPropagation();\n          onSearchOpenChange(true);\n\n          if (!isInDataGrid && !isInSearchInput) {\n            requestAnimationFrame(() => {\n              dataGridElement.focus();\n            });\n          }\n          return;\n        }\n      }\n\n      const isInDataGrid = dataGridElement.contains(target);\n      if (!isInDataGrid) return;\n\n      if (key === \"Escape\") {\n        const currentState = store.getState();\n        const hasSelections =\n          currentState.selectionState.selectedCells.size > 0 ||\n          Object.keys(currentState.rowSelection).length > 0;\n\n        if (hasSelections) {\n          event.preventDefault();\n          event.stopPropagation();\n          clearSelection();\n        }\n      }\n    }\n\n    window.addEventListener(\"keydown\", onGlobalKeyDown, true);\n    return () => {\n      window.removeEventListener(\"keydown\", onGlobalKeyDown, true);\n    };\n  }, [enableSearch, onSearchOpenChange, store, clearSelection]);\n\n  React.useEffect(() => {\n    const currentState = store.getState();\n    if (\n      autoFocus &&\n      data.length > 0 &&\n      columns.length > 0 &&\n      !currentState.focusedCell\n    ) {\n      if (navigableColumnIds.length > 0) {\n        const rafId = requestAnimationFrame(() => {\n          if (typeof autoFocus === \"object\") {\n            const { rowIndex, columnId } = autoFocus;\n            if (columnId) {\n              focusCell(rowIndex ?? 0, columnId);\n            }\n            return;\n          }\n\n          const firstColumnId = navigableColumnIds[0];\n          if (firstColumnId) {\n            focusCell(0, firstColumnId);\n          }\n        });\n        return () => cancelAnimationFrame(rafId);\n      }\n    }\n  }, [\n    autoFocus,\n    data.length,\n    columns.length,\n    store,\n    navigableColumnIds,\n    focusCell,\n  ]);\n\n  React.useEffect(() => {\n    function onOutsideClick(event: MouseEvent) {\n      if (event.button === 2) {\n        return;\n      }\n\n      if (\n        dataGridRef.current &&\n        !dataGridRef.current.contains(event.target as Node)\n      ) {\n        const target = event.target;\n        const isInsidePopover =\n          target instanceof HTMLElement &&\n          (target.closest(\"[data-grid-cell-editor]\") ||\n            target.closest(\"[data-grid-popover]\"));\n\n        if (!isInsidePopover) {\n          blurCell();\n          const currentState = store.getState();\n          if (\n            currentState.selectionState.selectedCells.size > 0 ||\n            Object.keys(currentState.rowSelection).length > 0\n          ) {\n            clearSelection();\n          }\n        }\n      }\n    }\n\n    document.addEventListener(\"mousedown\", onOutsideClick);\n    return () => {\n      document.removeEventListener(\"mousedown\", onOutsideClick);\n    };\n  }, [store, blurCell, clearSelection]);\n\n  React.useEffect(() => {\n    function cleanup() {\n      document.removeEventListener(\"selectstart\", preventSelection);\n      document.removeEventListener(\"contextmenu\", preventContextMenu);\n      document.body.style.userSelect = \"\";\n    }\n\n    function preventSelection(event: Event) {\n      event.preventDefault();\n    }\n    function preventContextMenu(event: Event) {\n      event.preventDefault();\n    }\n\n    const unsubscribe = store.subscribe(() => {\n      const currentState = store.getState();\n      if (currentState.selectionState.isSelecting) {\n        document.addEventListener(\"selectstart\", preventSelection);\n        document.addEventListener(\"contextmenu\", preventContextMenu);\n        document.body.style.userSelect = \"none\";\n      } else {\n        cleanup();\n      }\n    });\n\n    return () => {\n      cleanup();\n      unsubscribe();\n    };\n  }, [store]);\n\n  useIsomorphicLayoutEffect(() => {\n    const rafId = requestAnimationFrame(() => {\n      rowVirtualizer.measure();\n    });\n    return () => cancelAnimationFrame(rafId);\n  }, [\n    table.getState().columnFilters,\n    table.getState().columnOrder,\n    table.getState().columnPinning,\n    table.getState().columnSizing,\n    table.getState().columnVisibility,\n    table.getState().expanded,\n    table.getState().globalFilter,\n    table.getState().grouping,\n    table.getState().rowSelection,\n    table.getState().sorting,\n    rowHeight,\n  ]);\n\n  return {\n    dataGridRef,\n    headerRef,\n    rowMapRef,\n    footerRef,\n    table,\n    rowVirtualizer,\n    searchState,\n    columnSizeVars,\n    scrollToRow,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/use-debounced-callback.ts",
      "content": "/**\n * @see https://github.com/mantinedev/mantine/blob/master/packages/@mantine/hooks/src/use-debounced-callback/use-debounced-callback.ts\n */\n\nimport * as React from \"react\";\n\nimport { useCallbackRef } from \"@/hooks/use-callback-ref\";\n\nexport function useDebouncedCallback<T extends (...args: never[]) => unknown>(\n  callback: T,\n  delay: number,\n) {\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = React.useRef(0);\n  React.useEffect(\n    () => () => window.clearTimeout(debounceTimerRef.current),\n    [],\n  );\n\n  const setValue = React.useCallback(\n    (...args: Parameters<T>) => {\n      window.clearTimeout(debounceTimerRef.current);\n      debounceTimerRef.current = window.setTimeout(\n        () => handleCallback(...args),\n        delay,\n      );\n    },\n    [handleCallback, delay],\n  );\n\n  return setValue;\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "src/lib/compose-refs.ts",
      "content": "/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n\nimport * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we don't want to re-run this callback when the refs change\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/data-grid.ts",
      "content": "import type { CellPosition, RowHeightValue } from \"@/types/data-grid\";\n\nexport function getCellKey(rowIndex: number, columnId: string) {\n  return `${rowIndex}:${columnId}`;\n}\n\nexport function parseCellKey(cellKey: string): Required<CellPosition> {\n  const parts = cellKey.split(\":\");\n  const rowIndexStr = parts[0];\n  const columnId = parts[1];\n  if (rowIndexStr && columnId) {\n    const rowIndex = parseInt(rowIndexStr, 10);\n    if (!Number.isNaN(rowIndex)) {\n      return { rowIndex, columnId };\n    }\n  }\n  return { rowIndex: 0, columnId: \"\" };\n}\n\nexport function getRowHeightValue(rowHeight: RowHeightValue): number {\n  const rowHeightMap: Record<RowHeightValue, number> = {\n    short: 36,\n    medium: 56,\n    tall: 76,\n    \"extra-tall\": 96,\n  };\n\n  return rowHeightMap[rowHeight];\n}\n\nexport function getLineCount(rowHeight: RowHeightValue): number {\n  const lineCountMap: Record<RowHeightValue, number> = {\n    short: 1,\n    medium: 2,\n    tall: 3,\n    \"extra-tall\": 4,\n  };\n\n  return lineCountMap[rowHeight];\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/types/data-grid.ts",
      "content": "import type { RowData } from \"@tanstack/react-table\";\n\nexport type RowHeightValue = \"short\" | \"medium\" | \"tall\" | \"extra-tall\";\n\nexport interface CellSelectOption {\n  label: string;\n  value: string;\n}\n\nexport type Cell =\n  | {\n      variant: \"short-text\";\n    }\n  | {\n      variant: \"long-text\";\n    }\n  | {\n      variant: \"number\";\n      min?: number;\n      max?: number;\n      step?: number;\n    }\n  | {\n      variant: \"select\";\n      options: CellSelectOption[];\n    }\n  | {\n      variant: \"multi-select\";\n      options: CellSelectOption[];\n    }\n  | {\n      variant: \"checkbox\";\n    }\n  | {\n      variant: \"date\";\n    };\n\nexport interface UpdateCell {\n  rowIndex: number;\n  columnId: string;\n  value: unknown;\n}\n\ndeclare module \"@tanstack/react-table\" {\n  // biome-ignore lint/correctness/noUnusedVariables: TData and TValue are used in the ColumnMeta interface\n  interface ColumnMeta<TData extends RowData, TValue> {\n    label?: string;\n    cell?: Cell;\n  }\n\n  // biome-ignore lint/correctness/noUnusedVariables: TData is used in the TableMeta interface\n  interface TableMeta<TData extends RowData> {\n    dataGridRef?: React.RefObject<HTMLElement | null>;\n    focusedCell?: CellPosition | null;\n    editingCell?: CellPosition | null;\n    selectionState?: SelectionState;\n    searchOpen?: boolean;\n    isScrolling?: boolean;\n    getIsCellSelected?: (rowIndex: number, columnId: string) => boolean;\n    getIsSearchMatch?: (rowIndex: number, columnId: string) => boolean;\n    getIsActiveSearchMatch?: (rowIndex: number, columnId: string) => boolean;\n    onDataUpdate?: (props: UpdateCell | Array<UpdateCell>) => void;\n    onColumnClick?: (columnId: string) => void;\n    onCellClick?: (\n      rowIndex: number,\n      columnId: string,\n      event?: React.MouseEvent,\n    ) => void;\n    onCellDoubleClick?: (rowIndex: number, columnId: string) => void;\n    onCellMouseDown?: (\n      rowIndex: number,\n      columnId: string,\n      event: React.MouseEvent,\n    ) => void;\n    onCellMouseEnter?: (\n      rowIndex: number,\n      columnId: string,\n      event: React.MouseEvent,\n    ) => void;\n    onCellMouseUp?: () => void;\n    onCellContextMenu?: (\n      rowIndex: number,\n      columnId: string,\n      event: React.MouseEvent,\n    ) => void;\n    onCellEditingStart?: (rowIndex: number, columnId: string) => void;\n    onCellEditingStop?: (opts?: {\n      direction?: NavigationDirection;\n      moveToNextRow?: boolean;\n    }) => void;\n    contextMenu?: ContextMenuState;\n    onContextMenuOpenChange?: (open: boolean) => void;\n    rowHeight?: RowHeightValue;\n    onRowHeightChange?: (value: RowHeightValue) => void;\n    onRowSelect?: (\n      rowIndex: number,\n      checked: boolean,\n      shiftKey: boolean,\n    ) => void;\n  }\n}\n\nexport interface CellPosition {\n  rowIndex: number;\n  columnId: string;\n}\n\nexport interface CellRange {\n  start: CellPosition;\n  end: CellPosition;\n}\n\nexport interface SelectionState {\n  selectedCells: Set<string>;\n  selectionRange: CellRange | null;\n  isSelecting: boolean;\n}\n\nexport interface ContextMenuState {\n  open: boolean;\n  x: number;\n  y: number;\n}\n\nexport type NavigationDirection =\n  | \"up\"\n  | \"down\"\n  | \"left\"\n  | \"right\"\n  | \"home\"\n  | \"end\"\n  | \"ctrl+home\"\n  | \"ctrl+end\"\n  | \"pageup\"\n  | \"pagedown\";\n\nexport interface SearchState {\n  searchMatches: CellPosition[];\n  matchIndex: number;\n  searchOpen: boolean;\n  onSearchOpenChange: (open: boolean) => void;\n  searchQuery: string;\n  onSearchQueryChange: (query: string) => void;\n  onSearch: (query: string) => void;\n  onNavigateToNextMatch: () => void;\n  onNavigateToPrevMatch: () => void;\n}\n",
      "type": "registry:file",
      "target": "src/types/data-grid.ts"
    }
  ]
}