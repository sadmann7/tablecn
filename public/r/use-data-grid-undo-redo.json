{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-data-grid-undo-redo",
  "title": "Use Data Grid Undo Redo",
  "description": "An undo/redo hook for the data grid with keyboard shortcuts and history management",
  "dependencies": [
    "sonner"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "src/hooks/use-data-grid-undo-redo.ts",
      "content": "import * as React from \"react\";\nimport { toast } from \"sonner\";\n\nimport { useAsRef } from \"@/hooks/use-as-ref\";\nimport { useLazyRef } from \"@/hooks/use-lazy-ref\";\n\nconst DEFAULT_MAX_HISTORY = 100;\n\ninterface HistoryEntry<TData> {\n  variant: \"cells_update\" | \"rows_add\" | \"rows_delete\";\n  count: number;\n  timestamp: number;\n  undo: (currentData: TData[]) => TData[];\n  redo: (currentData: TData[]) => TData[];\n}\n\ninterface UndoRedoCellUpdate {\n  rowIndex: number;\n  columnId: string;\n  previousValue: unknown;\n  newValue: unknown;\n}\n\ninterface UndoRedoState<TData> {\n  undoStack: HistoryEntry<TData>[];\n  redoStack: HistoryEntry<TData>[];\n}\n\ninterface UndoRedoStore<TData> {\n  subscribe: (callback: () => void) => () => void;\n  getState: () => UndoRedoState<TData>;\n  push: (entry: HistoryEntry<TData>) => void;\n  undo: () => HistoryEntry<TData> | null;\n  redo: () => HistoryEntry<TData> | null;\n  clear: () => void;\n  notify: () => void;\n}\n\nfunction useStore<T>(\n  store: UndoRedoStore<T>,\n  selector: (state: UndoRedoState<T>) => boolean,\n): boolean {\n  const getSnapshot = React.useCallback(\n    () => selector(store.getState()),\n    [store, selector],\n  );\n\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\n}\n\ninterface UseDataGridUndoRedoProps<TData> {\n  data: TData[];\n  onDataChange: (data: TData[]) => void;\n  maxHistory?: number;\n  enabled?: boolean;\n}\n\ninterface UseDataGridUndoRedoReturn<TData> {\n  canUndo: boolean;\n  canRedo: boolean;\n  onUndo: () => void;\n  onRedo: () => void;\n  onClear: () => void;\n  trackCellsUpdate: (updates: UndoRedoCellUpdate[]) => void;\n  trackRowsAdd: (params: { startIndex: number; rows: TData[] }) => void;\n  trackRowsDelete: (params: { indices: number[]; rows: TData[] }) => void;\n}\n\nfunction useDataGridUndoRedo<TData>({\n  data,\n  onDataChange,\n  maxHistory = DEFAULT_MAX_HISTORY,\n  enabled = true,\n}: UseDataGridUndoRedoProps<TData>): UseDataGridUndoRedoReturn<TData> {\n  const propsRef = useAsRef({\n    data,\n    onDataChange,\n    maxHistory,\n    enabled,\n  });\n\n  const listenersRef = useLazyRef(() => new Set<() => void>());\n\n  const stateRef = useLazyRef<UndoRedoState<TData>>(() => ({\n    undoStack: [],\n    redoStack: [],\n  }));\n\n  const store = React.useMemo<UndoRedoStore<TData>>(() => {\n    return {\n      subscribe: (callback) => {\n        listenersRef.current.add(callback);\n        return () => listenersRef.current.delete(callback);\n      },\n      getState: () => stateRef.current,\n      push: (entry) => {\n        const state = stateRef.current;\n        const newUndoStack = [...state.undoStack, entry];\n\n        if (newUndoStack.length > propsRef.current.maxHistory) {\n          newUndoStack.shift();\n        }\n\n        stateRef.current = {\n          undoStack: newUndoStack,\n          redoStack: [],\n        };\n        store.notify();\n      },\n      undo: () => {\n        const state = stateRef.current;\n        if (state.undoStack.length === 0) return null;\n\n        const entry = state.undoStack[state.undoStack.length - 1];\n        if (!entry) return null;\n\n        stateRef.current = {\n          undoStack: state.undoStack.slice(0, -1),\n          redoStack: [...state.redoStack, entry],\n        };\n        store.notify();\n        return entry;\n      },\n      redo: () => {\n        const state = stateRef.current;\n        if (state.redoStack.length === 0) return null;\n\n        const entry = state.redoStack[state.redoStack.length - 1];\n        if (!entry) return null;\n\n        stateRef.current = {\n          undoStack: [...state.undoStack, entry],\n          redoStack: state.redoStack.slice(0, -1),\n        };\n        store.notify();\n        return entry;\n      },\n      clear: () => {\n        stateRef.current = {\n          undoStack: [],\n          redoStack: [],\n        };\n        store.notify();\n      },\n      notify: () => {\n        for (const listener of listenersRef.current) {\n          listener();\n        }\n      },\n    };\n  }, [listenersRef, stateRef, propsRef]);\n\n  const canUndo = useStore(store, (state) => state.undoStack.length > 0);\n  const canRedo = useStore(store, (state) => state.redoStack.length > 0);\n\n  const onUndo = React.useCallback(() => {\n    if (!propsRef.current.enabled) return;\n\n    const entry = store.undo();\n    if (!entry) {\n      toast.info(\"No actions to undo\");\n      return;\n    }\n\n    const newData = entry.undo(propsRef.current.data);\n    propsRef.current.onDataChange(newData);\n\n    toast.success(\n      `${entry.count} action${entry.count !== 1 ? \"s\" : \"\"} undone`,\n    );\n  }, [store, propsRef]);\n\n  const onRedo = React.useCallback(() => {\n    if (!propsRef.current.enabled) return;\n\n    const entry = store.redo();\n    if (!entry) {\n      toast.info(\"No actions to redo\");\n      return;\n    }\n\n    const newData = entry.redo(propsRef.current.data);\n    propsRef.current.onDataChange(newData);\n\n    toast.success(\n      `${entry.count} action${entry.count !== 1 ? \"s\" : \"\"} redone`,\n    );\n  }, [store, propsRef]);\n\n  const onClear = React.useCallback(() => {\n    store.clear();\n  }, [store]);\n\n  const trackCellsUpdate = React.useCallback(\n    (updates: UndoRedoCellUpdate[]) => {\n      if (!propsRef.current.enabled || updates.length === 0) return;\n\n      const filteredUpdates = updates.filter(\n        (u) => !Object.is(u.previousValue, u.newValue),\n      );\n      if (filteredUpdates.length === 0) return;\n\n      const entry: HistoryEntry<TData> = {\n        variant: \"cells_update\",\n        count: filteredUpdates.length,\n        timestamp: Date.now(),\n        undo: (currentData) => {\n          const newData = [...currentData];\n          for (const update of filteredUpdates) {\n            const row = newData[update.rowIndex];\n            if (row) {\n              newData[update.rowIndex] = {\n                ...row,\n                [update.columnId]: update.previousValue,\n              };\n            }\n          }\n          return newData;\n        },\n        redo: (currentData) => {\n          const newData = [...currentData];\n          for (const update of filteredUpdates) {\n            const row = newData[update.rowIndex];\n            if (row) {\n              newData[update.rowIndex] = {\n                ...row,\n                [update.columnId]: update.newValue,\n              };\n            }\n          }\n          return newData;\n        },\n      };\n\n      store.push(entry);\n    },\n    [store, propsRef],\n  );\n\n  const trackRowsAdd = React.useCallback(\n    (params: { startIndex: number; rows: TData[] }) => {\n      if (!propsRef.current.enabled || params.rows.length === 0) return;\n\n      const { startIndex, rows } = params;\n\n      const indicesAsc = rows.map((_, i) => startIndex + i);\n      const indicesDesc = [...indicesAsc].sort((a, b) => b - a);\n\n      const rowsCopy = rows.map((row) => structuredClone(row));\n\n      const entry: HistoryEntry<TData> = {\n        variant: \"rows_add\",\n        count: rows.length,\n        timestamp: Date.now(),\n        undo: (currentData) => {\n          const newData = [...currentData];\n          for (const index of indicesDesc) {\n            newData.splice(index, 1);\n          }\n          return newData;\n        },\n        redo: (currentData) => {\n          const newData = [...currentData];\n          for (let i = 0; i < indicesAsc.length; i++) {\n            const index = indicesAsc[i];\n            const row = rowsCopy[i];\n            if (index !== undefined && row) {\n              newData.splice(index, 0, structuredClone(row));\n            }\n          }\n          return newData;\n        },\n      };\n\n      store.push(entry);\n    },\n    [store, propsRef],\n  );\n\n  const trackRowsDelete = React.useCallback(\n    (params: { indices: number[]; rows: TData[] }) => {\n      if (!propsRef.current.enabled || params.indices.length === 0) return;\n\n      const { indices, rows } = params;\n\n      const rowsWithIndices: Array<{ index: number; row: TData }> = [];\n      for (let i = 0; i < indices.length; i++) {\n        const index = indices[i];\n        const row = rows[i];\n        if (index !== undefined && row !== undefined) {\n          rowsWithIndices.push({\n            index,\n            row: structuredClone(row),\n          });\n        }\n      }\n      rowsWithIndices.sort((a, b) => a.index - b.index);\n\n      const indicesDesc = rowsWithIndices\n        .map((item) => item.index)\n        .sort((a, b) => b - a);\n\n      const entry: HistoryEntry<TData> = {\n        variant: \"rows_delete\",\n        count: rows.length,\n        timestamp: Date.now(),\n        undo: (currentData) => {\n          const newData = [...currentData];\n          for (const { index, row } of rowsWithIndices) {\n            newData.splice(index, 0, structuredClone(row));\n          }\n          return newData;\n        },\n        redo: (currentData) => {\n          const newData = [...currentData];\n          for (const index of indicesDesc) {\n            newData.splice(index, 1);\n          }\n          return newData;\n        },\n      };\n\n      store.push(entry);\n    },\n    [store, propsRef],\n  );\n\n  React.useEffect(() => {\n    if (!enabled) return;\n\n    function onKeyDown(event: KeyboardEvent) {\n      const isCtrlOrCmd = event.ctrlKey || event.metaKey;\n\n      if (isCtrlOrCmd && event.key.toLowerCase() === \"z\" && !event.shiftKey) {\n        event.preventDefault();\n        onUndo();\n        return;\n      }\n\n      if (\n        (isCtrlOrCmd && event.key.toLowerCase() === \"z\" && event.shiftKey) ||\n        (isCtrlOrCmd && event.key.toLowerCase() === \"y\")\n      ) {\n        event.preventDefault();\n        onRedo();\n        return;\n      }\n    }\n\n    document.addEventListener(\"keydown\", onKeyDown);\n    return () => document.removeEventListener(\"keydown\", onKeyDown);\n  }, [enabled, onUndo, onRedo]);\n\n  return React.useMemo(\n    () => ({\n      canUndo,\n      canRedo,\n      onUndo,\n      onRedo,\n      onClear,\n      trackCellsUpdate,\n      trackRowsAdd,\n      trackRowsDelete,\n    }),\n    [\n      canUndo,\n      canRedo,\n      onUndo,\n      onRedo,\n      onClear,\n      trackCellsUpdate,\n      trackRowsAdd,\n      trackRowsDelete,\n    ],\n  );\n}\n\nexport {\n  useDataGridUndoRedo,\n  //\n  type UndoRedoCellUpdate,\n};\n",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/use-as-ref.ts",
      "content": "import * as React from \"react\";\n\nimport { useIsomorphicLayoutEffect } from \"@/hooks/use-isomorphic-layout-effect\";\n\nfunction useAsRef<T>(props: T) {\n  const ref = React.useRef<T>(props);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = props;\n  });\n\n  return ref;\n}\n\nexport { useAsRef };\n",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/use-lazy-ref.ts",
      "content": "import * as React from \"react\";\n\nfunction useLazyRef<T>(fn: () => T): React.RefObject<T> {\n  const ref = React.useRef<T | null>(null);\n  if (ref.current === null) {\n    ref.current = fn();\n  }\n  return ref as React.RefObject<T>;\n}\n\nexport { useLazyRef };\n",
      "type": "registry:hook"
    }
  ],
  "type": "registry:hook"
}